<!DOCTYPE html>


<html lang="zh-Hans">


<head>
  <meta charset="utf-8" />
   
  <meta name="keywords" content="Java" />
   
  <meta name="description" content="本站是ITaylorfan的个人博客" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    计算机三级数据库笔记 |  ITaylorfan的博客
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/images/TS-10-21.jpg" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

<link rel="alternate" href="/atom.xml" title="ITaylorfan的博客" type="application/atom+xml">
</head>

</html>
<script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css">
<body>
  <div id="app">
    <main class="content on">
      <section class="outer">
  <article id="post-计算机三级数据库笔记" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  计算机三级数据库笔记
</h1>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2021/03/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2021-03-28T11:04:35.000Z" itemprop="datePublished">2021-03-28</time>
</a>
      
      
      
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数:</span>
            <span class="post-count">21.3k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长 ≈</span>
            <span class="post-count">73 min</span>
        </span>
    </span>
</div>

      
    </div>
    

    
    
    <div class="tocbot"></div>





    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="计算机三级数据库第一套题"><a href="#计算机三级数据库第一套题" class="headerlink" title="计算机三级数据库第一套题"></a>计算机三级数据库第一套题</h1><h2 id="一、选择题"><a href="#一、选择题" class="headerlink" title="一、选择题"></a>一、选择题</h2><ol>
<li><p><strong>应用服务器</strong>从数据库服务器接收数据并返回给客户端。</p>
</li>
<li><p>关系模型是<strong>静态稳定的</strong>，关系是<strong>动态的</strong>，<strong>随用户操作变化</strong>。</p>
</li>
<li><p>设计人机界面可采用<strong>原型迭代法</strong>，首先进行用户界面<strong>初步设计</strong>，然后与用户不断讨论，改进设计方案。</p>
</li>
<li><p><strong>不能</strong>删除数据库中的日志内容，以获得更多的空间。（<strong>会破坏数据库的安全性和可靠性</strong>）</p>
</li>
<li><p>创建索引的SQL语句格式:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> [<span class="keyword">unique</span>] <span class="keyword">index</span> &lt;索引名&gt; <span class="keyword">on</span> &lt;表名&gt; (&lt;列名&gt;[&lt;次序&gt;],&lt;列名&gt;[&lt;次序&gt;],) <span class="keyword">include</span> (属性名) <span class="keyword">where</span> 约束条件</span><br></pre></td></tr></table></figure>

<a id="more"></a>
</li>
<li><p>（<em>）在对用户进行授权时 *</em>deny修饰符<strong>表示拒绝。</strong>权限冲突时deny优先**。</p>
<p>deny(拒绝)与不授权的区别:</p>
<blockquote>
<p>deny <strong>不可继承</strong>其他角色中已有的权限 ，不授权<strong>可以继承</strong>其他角色中已有的权限</p>
</blockquote>
</li>
<li><p><strong>db_datawriter</strong>角色具有:<strong>插入、删除、更新操作</strong>;不具有查询操作。</p>
</li>
<li><p>将属性值作为参数，<strong>不采用索引键值比较</strong>，而是采用一定的计算方法定位数据的是<strong>散列(哈希)索引</strong>。</p>
</li>
<li><p>系统数据库 master、model、msdb、tempdb和用户数据库，备份策略。</p>
<blockquote>
<p>master、model、msdb修改后<strong>立即备份</strong>。</p>
<p>tempdb<strong>无须备份</strong>、临时文件每次启动都会清空。</p>
<p><strong>用户数据库周期性备份</strong>。</p>
</blockquote>
</li>
<li><p>文件备份<strong>仅对数据库文件备份</strong>，<strong>不会对日志文件进行备份</strong>。</p>
<blockquote>
<p><strong>文件备份</strong>、<strong>差异文件备份</strong>完成后需要对日志文件再进行备份。</p>
<p><strong>完整数据库备份</strong>、<strong>差异数据库备份</strong>完成后<strong>不需要</strong>再备份日志文件。</p>
</blockquote>
</li>
<li><p><strong>介质故障</strong>，又称为<strong>硬故障</strong>，是指物理设备的损坏导致数据库无法运行。</p>
</li>
<li><p><strong>系统故障</strong>是指造成系统停止运转的任何事件，使得系统要重新启动。</p>
</li>
<li><p>（<em>）*</em>分布式数据库<strong>中的</strong>分布透明性**包括：</p>
<blockquote>
<p>分片透明性</p>
<p>位置透明性</p>
<p>局部数据模型透明性</p>
</blockquote>
</li>
<li><p>在并行数据库中，需要将表拆分到不同的磁盘上。</p>
<p>并行数据库常用划分方法有:</p>
<blockquote>
<p>轮转法、散列划分、范围划分</p>
</blockquote>
<p><strong>最适合整表扫描的拆分方式是:轮转法</strong></p>
<blockquote>
<p>轮转法在扫描时可以并行地从几个磁盘中读取数据，负载平衡，充分发挥了并行性。</p>
</blockquote>
</li>
</ol>
<h2 id="二、应用题"><a href="#二、应用题" class="headerlink" title="二、应用题"></a>二、应用题</h2><ol>
<li><p>数据库管理系统提供了数据定义语言(DDL),用于定义各种数据库对象。数据定义语句经DDL编译器编译后，各种对象的描述信息存放在数据库的<u><strong>数据字典</strong></u>中。(<strong>数据字典</strong>:数据项、数据结构、数据流、数据存储和数据处理)。</p>
</li>
<li><p>关系数据库中要求关系的主码不能为空，这属于数据模型三要素中的<strong><u>完整性约束</u></strong>（<strong>三要素</strong>:数据结构、数据操作和完整性约束）。</p>
</li>
<li><p>数据库主要角色及权限:</p>
<table>
<thead>
<tr>
<th align="center">角色</th>
<th align="center">权限</th>
</tr>
</thead>
<tbody><tr>
<td align="center">bulkadmin</td>
<td align="center">执行BULK INSERT语句(高效导入大量数据量的平面文件)</td>
</tr>
<tr>
<td align="center">dbccreator</td>
<td align="center">创建、修改、删除和还原数据库</td>
</tr>
<tr>
<td align="center">diskadmin</td>
<td align="center">管理磁盘文件</td>
</tr>
<tr>
<td align="center">processadmin</td>
<td align="center">管理在SQL Server实例中运行的进程</td>
</tr>
<tr>
<td align="center">securityadmin</td>
<td align="center">管理服务器登录账户</td>
</tr>
<tr>
<td align="center">serveradmin</td>
<td align="center">配置服务器范围设置</td>
</tr>
<tr>
<td align="center">setupadmin</td>
<td align="center">添加和删除链接服务器</td>
</tr>
<tr>
<td align="center">sysadmin</td>
<td align="center">在SQL Server中进行任何活动，该角色的权限跨越所有其它固定服务器角色。</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
</li>
<li><p>数据库管理系统一般通过周期性检查<u><strong>事物等待图</strong></u>来实现死锁检测。</p>
</li>
<li><p>一个事物执行过程中，其正在访问的数据被其他事物修改，导致处理结果不正确。这是由于不满足并发事物间的<strong><u>隔离性</u></strong>而引起的。</p>
</li>
<li><p>在数据库系统出现故障后进行恢复。</p>
<blockquote>
<p>故障时<strong>已经</strong>提交的执行<strong>redo</strong>操作</p>
<p>故障时<strong>未</strong>提交的执行<strong>undo</strong>操作</p>
</blockquote>
</li>
<li><p>并行数据服务器分为两种结构：<strong>完全共享资源结构</strong>和<strong>完全不共享资源结构</strong>。</p>
</li>
<li><p>（<em>）数据仓库是<u>*</em>一个面向主题的、集成的、非易失的、且随时间变化的数据集合**</u>。</p>
</li>
<li><p>粒度是反映数据库系统中综合程度的指标。表中属性<u><strong>细化越低，粒度越大</strong></u>。越详细粒度越小。</p>
</li>
</ol>
<h2 id="三、PL-SQL语句"><a href="#三、PL-SQL语句" class="headerlink" title="三、PL/SQL语句"></a>三、PL/SQL语句</h2><p><strong>格式：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> 过程名</span><br><span class="line">@[参数名] [类型],@[参数名][类型] <span class="comment">/*过程首部 默认是输入参数 可以加output修饰 成为输出参数*/</span>  </span><br><span class="line"><span class="keyword">AS</span>		<span class="comment">/*as下面对应的&lt;PL/SQL&gt;块 为过程体*/</span></span><br><span class="line">	<span class="keyword">Declare</span></span><br><span class="line">	******</span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">	******</span><br><span class="line">	<span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h1 id="计算机三级数据库第二套题"><a href="#计算机三级数据库第二套题" class="headerlink" title="计算机三级数据库第二套题"></a>计算机三级数据库第二套题</h1><h2 id="一、选择题-1"><a href="#一、选择题-1" class="headerlink" title="一、选择题"></a>一、选择题</h2><ol>
<li><p>（<em>）*</em>存储管理器**负责检查用户是否具有数据访问权限。</p>
</li>
<li><p><strong>查询处理器</strong>会为编译好的查询语句生成执行计划，并根据执行计划访问相关数据。</p>
</li>
<li><p>三级模式结构和数据独立性：</p>
<blockquote>
<ol>
<li>在一个数据库中可以定义<strong>多个外模式</strong>，而<strong>内模式只有一个</strong>。</li>
<li>三级模式结构提供了数据独立性，即当数据的逻辑结构和存储结构发生变化时，应用程序不受影响。</li>
</ol>
</blockquote>
</li>
<li><p><strong>前触发型触发器</strong>只执行触发器指定的内容而不执行引发触发器的SQL语句。</p>
</li>
<li><p>（<em>）创建一个新的用户数据库时，该用户数据库主要数据文件的大小*</em>不能小于 model数据库**主要数据文件的大小。(model数据库为新数据库提供模板)。</p>
</li>
<li><p>在创建表时，当用check进行约束条件限制时，若其只涉及对某一列的约束则可以放在该列后面，<strong>如果是约束条件中涉及两列或两列以上，则为整个表的约束，放在表的最后面。</strong></p>
</li>
<li><p>视图在SQL语句相同的情况下不能提高查询效率。</p>
</li>
<li><p><strong>基于锁的并发控制技术</strong>：</p>
<p>数据库中的锁主要分为共享锁和排它锁。</p>
<blockquote>
<ol>
<li><strong>当事务T对某个数据加上排它锁时，T可以对该数据进行读和写，其他任何事务都不能再对该数据加任何类型的锁，直到T释放该锁才行；</strong></li>
<li><strong>当事务T对某个数据加上共享锁，则T只能对该数据进行读操作，不能修改数据，且其他事务也可以对该数据加共享锁但不能加排它锁。只有等到该数据没有被其他任何事务访问时才能加排它锁。</strong></li>
</ol>
</blockquote>
<blockquote>
<ol>
<li>锁是一种特殊的二元信号量，用来控制多个并发事物对共享资源的使用。</li>
<li>数据库系统可以采用先来先服务的方式防止出现活锁现象。</li>
<li>当数据库管理系统检测到死锁后，可以采用撤销死锁事物的方式解除死锁。</li>
</ol>
</blockquote>
</li>
<li><p><strong>主索引是根据数据对象的主键建立的索引</strong>，<strong>它们决定了被索引记录的位置</strong>，而<strong>辅助索引</strong>没有这样的限制，<strong>可以用于任何索引目的并且可以查找多个数据文件的存放位置</strong>。而<strong>位图索引一般在范围查询时使用</strong>。</p>
</li>
<li><p>表在创建时必须设置主码，<strong>若未设置</strong>则<strong>默认所有属性集合为主码</strong>。</p>
</li>
<li><p><strong>日志文件</strong></p>
<blockquote>
<ol>
<li><strong>日志写入顺序必须和并行事务执行的时间次序一致</strong>，因为这样才能在数据库恢复时进行redo和undo操作，<strong>从而保证数据的一致性而不会产生脏数据</strong>。</li>
<li><strong>必须先写日志再写数据库</strong>，这样当数据库发生故障时可以根据日志完全恢复，否则如果先写数据，当数据刚写完时，数据库故障而没来得及写日志，导致数据恢复时发生错误。</li>
<li><strong>日志文件中检查点记录的主要作用是提高系统出现故障后的恢复速率</strong>。</li>
</ol>
</blockquote>
</li>
<li><p>恢复数据库正确的实例语句：</p>
<p><strong>先恢复数据库，再恢复日志文件</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">restore</span> <span class="keyword">database</span> MyDB <span class="keyword">from</span> BK <span class="keyword">with</span> <span class="keyword">file</span>=<span class="number">1</span>,norecovery  <span class="comment">/*norecovery恢复后数据库不可以用*/</span></span><br><span class="line"><span class="keyword">restore</span> <span class="keyword">log</span> MyDB <span class="keyword">from</span> BK <span class="keyword">with</span> <span class="keyword">file</span>=<span class="number">2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>master数据库可以使用的备份方法<strong>只有完整备份</strong>。(master最重要的数据库)</p>
</li>
<li><p><strong>并行数据库</strong></p>
<blockquote>
<ol>
<li><strong>并行数据库系统的主要目的是通过高速通信介质连接多个可独立处理的单元以并行执行的方式完成对数据库系统的互联查询、内部查询以及各种内部操作</strong>。<strong>分布式数据库系统的主要目的是实现场地自治和数据全局透明共享</strong>。</li>
<li>层次结构可以分为两层，<strong>顶层是无共享结构</strong>，<strong>底层是共享内存或共享磁盘结构</strong>。</li>
<li><strong>无共享结构通过最小化共享资源来降低资源竞争</strong>，<strong>因此具有很高的可扩展性</strong>，<strong>适合于OLTP(联机事务处理)应用</strong>。</li>
<li><strong>并行数据库系统经常通过负载均衡的方法来提高数据库系统的业务吞吐率</strong>。</li>
</ol>
</blockquote>
</li>
<li><p>现有一个具有多个分店的大型连锁超市，……为了提高数据访问率，系统将每年每个分店的销售数据分成独立的数据表，这种划分方式为<strong><u>多维划分</u></strong>。（维是人们观察事物的角度，同样的数据从不同维进行观察可能会得到不同的结果。）</p>
</li>
<li><p><strong>分布式数据库</strong>的<strong>分配方式</strong>包括<strong>集中式、分割式、全复制式、混合式</strong>。</p>
<blockquote>
<ol>
<li><strong>集中式：所有数据片断都安排在一个场地上；</strong></li>
<li><strong>分割式：全局数据有且只有一份，它们被划分成若干片段，每个片段被分配在一个特定的场地上；</strong></li>
<li><strong>全复制式：每个站点都有全局数据的复制样本，数据的冗余性最大；</strong></li>
<li><strong>混合式：全局数据被分成若干个数据子集，每个子集都被安排在一个或多个不同的场地上，但每个场地未必保存所有数据。</strong></li>
</ol>
</blockquote>
</li>
<li><p><strong>联机事务处理(OLTP)</strong>和<strong>联机分析处理(OLAP)：</strong></p>
<blockquote>
<ol>
<li><p><strong>OLTP是对数据库联机的日常操作，通常是对一条记录的查询和修改，要求快速响应用户的请求，对数据的安全性、完整性及事务吞吐量要求很高。</strong></p>
</li>
<li><p><strong>OLAP是对数据的查询和分析操作，通常是对海量历史数据的查询和分析，要访问的数据量非常大，查询和分析操作十分复杂。</strong></p>
</li>
<li><p><strong>OLAP为宏观分析，OLTP为微观操作，所以前者面向中上层和决策者使用，而后者面向企业的中下层业务人员使用</strong>。</p>
</li>
</ol>
</blockquote>
</li>
</ol>
<h2 id="二、应用题-1"><a href="#二、应用题-1" class="headerlink" title="二、应用题"></a>二、应用题</h2><ol>
<li><p>设用UML设计某数据库应用系统，设计人员规划了一组应用程序集，该集合由动态链接库和可执行程序构成。为了展现这些应用程序集间的组织和依赖关系，以对源代码、可执行程序的发布等进行系统建模，应采用的UML图是 <u><strong>组件</strong></u> 图。</p>
<blockquote>
<p><strong><em>(组件图提供系统的物理视图。UML图形中组件图的用途是显示系统中的软件对其他软件组件(列如，库函数))的依赖关系，它可以在一个非常高的层次上显示，从而仅显示粗粒度的组件，也可以在组件包层次上显示。</em></strong></p>
</blockquote>
</li>
<li><p><strong>自连接</strong>是SQL语句中经常要用的连接方式，使用自连接可以将自身表的一个镜像当做另一张表来对待，从而得到一些特殊的数据。简而言之，<strong>自连接的本意就是将一张表看成多张表来做连接</strong>。</p>
</li>
<li><p>在SQL Server 2008的某用户数据库中，设有T表，现要在T表的c1列和c2列上建立一个复合唯一聚集索引，其中c1列值重复率为20%，c2列为10%。建立一个性能最优的索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span>  <span class="keyword">unique</span>  clustered  <span class="keyword">index</span>  Idx1 <span class="keyword">on</span> T(c2,c1);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>聚集索引是指索引项的顺序与表中记录的物理顺序一致的索引组织。用户可以在最经常查询的列上建立聚集索引以提高查询效率。unique表示要建立的每一个索引值对应唯一的数据记录，先对c2表索引然后对c1表索引，可以使索引的性能最优。</strong></p>
</blockquote>
</li>
<li><p>（<em>）数据库管理系统中的加锁协议规定了事务的加锁时间、持续时间和释放锁时间，其中<u>*</em>三级加锁**</u>协议可以完全保证并发事务数据的一致性。</p>
<blockquote>
<p><strong>三级加锁协议也称为三级封锁协议，它保证正确地调度事务的并发操作，是事务对数据库对象加锁、解锁必须遵守的一种规则。在运用X锁（排它锁）和S锁（共享锁）对数据对象加锁时，还需要约定一些规则，列如何时申请X锁和S锁、持锁时间、何时释放等。</strong></p>
</blockquote>
</li>
<li><p>（<em>）通常数据库的转储机制用三种，分别是*</em><u>完全转储</u><strong>、</strong><u>差量转储</u><strong>和</strong><u>增量转储</u>**。</p>
<blockquote>
<ol>
<li><p><strong>完全转储：是指对整个数据库中的数据全部重新备份，效率低，时间长；</strong></p>
</li>
<li><p><strong>差量转储：是指基于上一次完全转储基点之后变化转储，是对上次转储以后对所有文件中修改或删除的记录的转储，效率高，时间短；</strong></p>
</li>
<li><p><strong>增量转储是对数据库中凡是有记录变化的文件的整个文件进行复制，效率介于前两种转储方式之间。</strong></p>
</li>
</ol>
</blockquote>
</li>
<li><p>在数据仓库设计和建设过程中，设计者需要调查用户的决策或数据处理需求，并将功能相近且需要相关联数据支持的需求进行归类，得到不同的需求集合，并在企业数据模型中寻找能够满足各个需求集合的数据集合，然后针对各个数据集合开展数据仓库数据模型的设计。这种设计方法称为<strong><u>面向主题</u></strong>的设计方法。</p>
<blockquote>
<p><strong>面向主题的数据组织方式，就是在较高层次上对分析对象数据的一个完整并且一致的描述，能刻画各个分析对象所涉及的企业各项数据，以及数据之间的联系。所谓较高层级是相对面向应用的数据组织方式而言的，即按照主题进行数据组织的方式具有更高的数据抽象级别。与传统数据库面向应用进行数据组织的特点相对应，数据仓库中的数据面向主题进行组织。例如，一个生产企业的数据仓库所组织的主题可能有产品订货分析和货物发运分析等。</strong></p>
</blockquote>
</li>
<li><p><strong>数据仓库是为了构建新的分析处理环境而出现的一种数据存储的组织技术。</strong></p>
</li>
</ol>
<h1 id="计算机三级数据库第三套题"><a href="#计算机三级数据库第三套题" class="headerlink" title="计算机三级数据库第三套题"></a>计算机三级数据库第三套题</h1><h2 id="一、选择题-2"><a href="#一、选择题-2" class="headerlink" title="一、选择题"></a>一、选择题</h2><ol>
<li><p>对模式进行分解时，既要保证分解具有“无损连接性”，又要保证分解“保持函数依赖”。</p>
<blockquote>
<p><strong>无损连接</strong>，指分解的若干连接重组时可以精确恢复到原来的数据表，数据的记录既没有增加也没有减少。</p>
<p><strong>保持函数依赖</strong>，指原关系模式有的属性之间的隐含关系在分解后不能丢失。</p>
</blockquote>
</li>
<li><p><strong>数据库物理设计</strong></p>
<blockquote>
<ol>
<li>物理设计着眼于数据库底层的物理存储与存取，与操作系统和硬件环境及数据库管理系统密切相关。</li>
<li>为了提高系统的性能，应该根据应用情况将数据的易变部分和稳定部分、经常存储部分和存取频率较低的部分分开存放，较常用的放在高速读写的磁盘上。根据访问频率定。</li>
<li>物理设计过程中需要考虑设置合理的数据库管理系统参数和操作系统相关参数。</li>
<li><strong>物理设计过程中需要考虑RAID级别、操作系统的文件管理机制、数据库管理系统支持的索引类型。</strong></li>
</ol>
</blockquote>
</li>
<li><p><strong>三层浏览器/服务器(B/S)架构是现在比较流行的应用系统架构。</strong></p>
<blockquote>
<ol>
<li>表示层使用Web浏览器实现，位于客户端，一般无需安装其他程序。</li>
<li>数据层位于数据库服务器，由DBMS完成数据存储和数据存取等数据管理功能。</li>
<li>此架构将人机交互、应用业务逻辑和数据管理三类功能分离，提高了可维护性。</li>
<li><strong>与二层的客户/服务器(C/S)架构相比较。三层架构将更多的任务传给服务器端计算，所以增加了网络的通信量，其运行速度受制于网络，并不一定会提高。在适用Internet、维护工作量等方面，B/S比C/S强；在运行速度、数据安全和人机交互等方面，不如C/S.</strong></li>
</ol>
</blockquote>
</li>
<li><p><strong>关于关系数据模型和关系表的说法</strong></p>
<blockquote>
<ol>
<li>关系数据模型以集合论为基础表述和处理数据</li>
<li><strong>关系数据语言分为关系代数语言、关系演算语言和兼具两者双重特点的语言，如SQL，但所有这些语言的共同点是<u>非过程化的</u>集合操作语言。</strong></li>
<li>在关系表上执行select或delete操作时，DBMS会检查数据完整性约束。（错）查询数据表时SQL语句不会检查数据的完整性约束。</li>
</ol>
</blockquote>
</li>
<li><p>数据库物理设计</p>
<blockquote>
<ol>
<li>在频繁执行插入、修改和删除操作的表上建立索引可能会降低系统的整体性能。</li>
<li>在一张表的某列上需要频繁执行精确匹配查询时，可以考虑为此列<strong>建立哈希索引</strong>。</li>
<li><strong>为了提高写入性能，数据库一般应尽量避免存储在RAID10的磁盘存储系统中。(<u>错</u>！)RAID10比RAID5在写数据上更稳定、速度更快、所以应尽量存储在RAID10的磁盘存储系统中。</strong></li>
<li>如果系统中存在频繁的多表连接操作，可以考虑将这些基本表组织为聚集文件，以提高查询效率。</li>
</ol>
</blockquote>
</li>
<li><p>UML的类图</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>图形样式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>类</td>
<td>空心三角实线</td>
<td>子类对父类的继承</td>
</tr>
<tr>
<td>接口</td>
<td>空心三角虚线</td>
<td>多继承</td>
</tr>
<tr>
<td>聚合关系</td>
<td>空心菱形实线</td>
<td>弱拥有关系</td>
</tr>
<tr>
<td>合成关系</td>
<td>实心菱形实线</td>
<td>强拥有严格的整体关系</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p>SQL中case when语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*简单赋值查询用法*/</span></span><br><span class="line">case sex</span><br><span class="line">when '1' then '男'</span><br><span class="line">when '2' then '女'</span><br><span class="line">else '其他'</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*复杂赋值查询用法*/</span></span><br><span class="line"><span class="keyword">case</span>  <span class="comment">/*注意这里没有变量名*/</span></span><br><span class="line">	<span class="keyword">when</span> Grade <span class="keyword">between</span> <span class="number">90</span> <span class="keyword">and</span> <span class="number">100</span> <span class="keyword">then</span> <span class="string">'优'</span></span><br><span class="line">	<span class="comment">/*省略*/</span></span><br><span class="line">	<span class="keyword">when</span> Grade <span class="keyword">between</span> <span class="number">60</span> <span class="keyword">and</span> <span class="number">69</span> <span class="keyword">then</span> <span class="string">'及格'</span></span><br><span class="line">	<span class="keyword">else</span> <span class="string">'不及格'</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>标量函数</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*示例*/</span></span><br><span class="line"><span class="keyword">Create</span> <span class="keyword">FUNCTION</span> dbo.GetTotal(@GoodID <span class="built_in">char</span>(<span class="number">6</span>))</span><br><span class="line"><span class="keyword">Returns</span> <span class="built_in">int</span> <span class="keyword">AS</span>          <span class="comment">/*AS可以去掉 注意此处是returns*/</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">Return</span> (<span class="keyword">select</span> <span class="keyword">sum</span>(销售价格) <span class="keyword">from</span> 销售表  <span class="keyword">where</span> 商品号=@GoodID)  <span class="comment">/*注意此处是return*/</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>分区表是将一个表的数据按水平方式划分为不同的子集，从而可以更快速有效地访问数据子集。现有表R(A,B)以及针对该表的SQL语句，如果基于列A对R进行范围分区，该分区设计方案能提高其性能的SQL语句是</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> A,<span class="keyword">sum</span>(B) <span class="keyword">from</span> R <span class="keyword">group</span> <span class="keyword">by</span> A</span><br></pre></td></tr></table></figure>

<p><strong>（A属性基于对R进行水平划分，即区别子集主要是通过A属性。）</strong></p>
</li>
<li><p><strong>（*）对于架构的说法：</strong></p>
<blockquote>
<ol>
<li><strong>架构是形成单个命名空间的数据库实体的集合。命名空间也是一个集合，其中每个元素的名称都是唯一的。架构与用户的关系是<u>一对多</u>的关系，<u>一个用户只能对应一个架构</u>，但多个用户可以共享一个架构。</strong></li>
<li><strong>架构相当于数据库对象的容器，在同一个数据库中架构不能重名。</strong></li>
<li><strong>架构是数据库中的逻辑命名空间，同一个数据库的不同架构中可以存在同名表。</strong></li>
<li><strong>在一个架构中可以定义表、视图等不同数据库对象</strong></li>
</ol>
</blockquote>
</li>
<li><p>设数据库管理员为SQL Server 2008默认实例中的某数据库实施了基于维护计划的数据库备份任务。配置完成后，发现此维护计划并未执行但数据库运行正常。有关此维护计划未执行的原因，最有可能的是 <u><strong>SQL Server 代理(MSSQLSERVER)</strong></u> 服务未启动。</p>
<blockquote>
<p><strong>SQL Server Agent是一个任务规划器的警报管理器，在实际应用环境下，可以先将那些周期性的活动定义成一个任务，然后让其在SQL Server Agent的帮助下自动运行。系统管理员，可以利用SQL Server Agent 向自己通知某些警告信息，从而定位出现的问题以提高管理效率。SQL Server Agent 主要包括以下几个组件：作业、警报和操作。</strong></p>
</blockquote>
</li>
<li><p><strong>SQL Server实例就是在数据库中存在的现实的数据库的例子，它是后台进程和数据库文件的集合</strong>。仅具有登录权限的用户对SQL Server 只能进行系统数据库中有关SQL Server的一些系统信息的查询，即只能对master、msdb数据库部分数据进行查询。.</p>
</li>
<li><p><strong>检测死锁有多种方法，包括超时法、等待图法等。事务等待图法动态地反映了所有事务的等待情况，并发控制的子系统<u>周期性地生成事务等待图进行检测</u>，而不是在执行每个事务时进行检测。</strong></p>
</li>
<li><p><strong>属于</strong>数据库日常监控内容：<strong>1.数据库空间使用情况。2.数据库缓冲区命中率情况。3.数据库中索引使用情况</strong>。</p>
<p><strong>不属于</strong>：数据库服务器网络是否畅通(操作系统管理员的职责)；数据库用户向数据库发送的每条SQL语句(数量庞大、且没有稳定的衡量指标，不属于监控范围)   </p>
</li>
<li><p>（<em>）*</em>数据库性能优化：**</p>
<blockquote>
<ol>
<li>增加派生性冗余列可以降低查询过程中的计算量。</li>
<li>增加冗余列可以减少查询过程中的UNION操作。（<strong>错</strong>）（增加冗余列指的是在多个表中添加相同的列，这样虽然增加了数据库服务器存储的负担，但可以减少查询过程中的JOIN（连接）操作，而不是UNION（并操作））</li>
<li>适当降低关系模式的规范化程度，可以减少查询过程中的JOIN操作。</li>
<li>当一个表的数据量超过一定规模时，可以采用分割表的方法提高效率。</li>
</ol>
</blockquote>
</li>
<li><p>减少数据库管理系统中的死锁，可以在<strong><u>应用程序设计过程</u></strong>中采取的措施</p>
<blockquote>
<ol>
<li>事务按同一顺序访问资源</li>
<li>将大事务切分成若干个小事务</li>
<li>使用绑定连接</li>
</ol>
</blockquote>
<p>检测事务等待图并撤销回路中的某个事务(<u><strong>不是在设计过程中</strong></u>  这是在数据库应用系统运行过程中由DBMS完成的操作)</p>
</li>
<li><p>数据库差异备份所备份的内容是：<strong>从最近的一次完整备份到当前时间数据库中变化的数据和日志。</strong></p>
</li>
<li><p>数据文件的空间使用量<strong>未必</strong>比日志文件大，因为日志是快速增长的。使用日志备份并<strong>不能降低数据库的备份空间。</strong></p>
</li>
<li><p><strong>（*）分布数据库分布透明性的描述:</strong></p>
<blockquote>
<ol>
<li>分片透明性是最高层次，指的是用户或应用程序只对全局关系进行操作而不必考虑关系分片的情况。</li>
<li>位置透明性是下一层次，指用户或应用程序只需了解数据分片情况，而不必了解片段的存储场地。</li>
<li>局部数据模型透明性指的是用户或用户程序不必了解局部场地上使用的是哪种数据模型，但是必须了解全局数据的分片情况，还需要了解各片段的副本复制情况及各片段和它们副本的场地位置分配情况。</li>
</ol>
</blockquote>
</li>
<li><p><strong>（*）元数据是关于数据的数据，或者叫做描述数据的数据。元数据描述了数据的结构、内容、链和索引等项内容。在关系数据中，这种描述就是对数据库、表、列等其他对象的定义。</strong></p>
</li>
</ol>
<h2 id="二、应用题-2"><a href="#二、应用题-2" class="headerlink" title="二、应用题"></a>二、应用题</h2><ol>
<li><p>如果数据文件中数据记录排列顺序与索引文件中索引项的排列顺序一致，则此种索引被称为<u><strong>聚集索引。</strong></u>(clustered)</p>
</li>
<li><p>关系数据库中的视图提供了<strong><u>逻辑</u></strong>数据独立性。</p>
</li>
<li><p>(<em>)在SQL Server 2008中，用于判断游标数据提取状态的全局变量是 <u>*</em>@@FETCH_STATUS**</u></p>
</li>
<li><p>datediff()函数用于计算两个日期之差。</p>
</li>
<li><p>在SQL Server 2008 中，只具有修改数据库中全部用户表数据权限的系统角色是<strong><u>db_datawriter</u></strong>。(9个SQL内置角色之一)</p>
</li>
<li><p>由于死锁导致的事务回滚属于数据库故障中的<u><strong>内部事务</strong></u>故障。</p>
<p>数据库系统中的故障的种类分为：</p>
<blockquote>
<p><strong>事务内部故障、系统故障、介质故障、计算机病毒。</strong></p>
<p><strong>事务内部故障分为预期事务内部故障和非预期事务内部故障。</strong>非预期的事务内部故障是不可预期的，不能由应用程序处理的，包括运算溢出、并发事务发生死锁而被撤销该事务、违反了某些完整性限制等。</p>
<p><strong>系统故障</strong>是造成系统停止运转的任何事件，使得系统需要重新启动。<strong>介质故障</strong>指硬件损坏等。</p>
</blockquote>
</li>
<li><p>(<em>)*</em>两阶段加锁协议<strong>可以保证事务调度的</strong><u>可串行</u>**性。</p>
<blockquote>
<p>DBMS对并发事务的不同的调度可能会产生不同的结果。为了衡量调度正确性，执行结果如果可以等价于串行调度则认为是正确的，这样的调度叫<strong>可串行调度</strong>。而<strong>两段加锁协议就是实现可串行调度的协议。</strong>若并发执行的所有事务均遵守两段锁协议，则这些事务的任何并发调度都是可串的。</p>
</blockquote>
</li>
<li><p>只复制最近一次数据库完全转储以来发生变化的数据的转储方式称为<strong>差量转储。</strong></p>
</li>
<li><p>(<em>)在分布数据库中，采用*</em><u>半连接</u>**操作可以减少场地之间的数据传输量。</p>
<blockquote>
<p>在一个关系传输到另一场地后，并非每个数据都参与连接操作，因此，不参与连接的数据或无用的数据不必在网络中来回传输。<strong>采用半连接操作即可在网络中只传输参与连接的数据。</strong></p>
</blockquote>
</li>
<li><p>(<em>)在进行多维分析时，如果将每年销售额投影到每个月上来进行观察，这种分析动作被称为*</em><u>钻取</u>**。</p>
<blockquote>
<p>常用的OLAP多维分析操作有切片、切块、旋转、下钻和卷起。</p>
<ol>
<li><strong>卷起</strong>：是在数据立方体中执行聚集操作，通过在维级别中上升或通过消除某个或某些维来观察更概括的数据。</li>
<li><strong>下钻</strong>：是通过在维级别中下降或通过引入某个或某些维来更细致的观察数据。</li>
<li><strong>切片和切块</strong>：实现局部数据的显示，帮助用户从众多混杂的数据中进行选择。</li>
<li><strong>旋转</strong>：就是改变维的方向。</li>
</ol>
</blockquote>
</li>
<li><p>（<em>）数据仓库中，元数据主要分为*</em><u>技术</u><strong>元数据和</strong><u>业务</u>**元数据两类。</p>
</li>
<li><p>创建视图中的 with schemabinding 关键字：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> 视图名</span><br><span class="line">	<span class="keyword">with</span> schemabinding</span><br><span class="line">	<span class="keyword">as</span></span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>schemabinding 选项，防止视图所引用的表在视图未被调整的情况下发生改变。一旦视图指定了with  schemabinding 选项，那么在修改当前视图的表或视图时，一旦对当前视图产生影响（导致视图失效），则不允许修改。</p>
</blockquote>
</li>
</ol>
<h2 id="三、分区方案"><a href="#三、分区方案" class="headerlink" title="三、分区方案"></a>三、分区方案</h2><ol>
<li><p>基于RangePF1分区函数创建分区方案RangePS1，每个分区对应一个文件组。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">partition</span> scheme RangePS1</span><br><span class="line"><span class="keyword">as</span> <span class="keyword">partition</span> RangePF1</span><br><span class="line"><span class="keyword">to</span>(文件组,文件组,文件组,文件组)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用RangePS1分区方案创建一个分区表PartitionT(Gid,GoodName,Price)，该表基于Gid列创建分区</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> PartitionT(</span><br><span class="line">	Gid <span class="built_in">int</span> <span class="keyword">identity</span>(<span class="number">1</span>,<span class="number">1</span>) primary <span class="keyword">key</span>,</span><br><span class="line">	GoodName <span class="built_in">varchar</span>(<span class="number">40</span>),</span><br><span class="line">	Price <span class="built_in">float</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">on</span> RangePS1(Gid)</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h1 id="计算机三级数据库第四套题"><a href="#计算机三级数据库第四套题" class="headerlink" title="计算机三级数据库第四套题"></a>计算机三级数据库第四套题</h1><h2 id="一、选择题-3"><a href="#一、选择题-3" class="headerlink" title="一、选择题"></a>一、选择题</h2><ol>
<li><p>用SQL语句描述事务活动。<strong>不属于逻辑设计所包含的活动</strong><u>（SQL语句通常不认为是设计范畴，已经实现了）</u></p>
</li>
<li><p>（<em>）包含索引设计的层次是：<u>*</em>数据持久层**</u>。</p>
<blockquote>
<p>数据库应用系统设计包括四个层次：1.表示层 、2.业务逻辑层 、3.数据访问层、4.数据持久层</p>
<p>数据持久层的设计工作属于数据组织与存储等方面的<strong>物理设计</strong>内容。</p>
<p>索引设计属于物理设计。</p>
</blockquote>
</li>
<li><p><strong>查询处理器</strong>和<strong>存储管理器</strong>是数据库管理系统中的核心模块。</p>
<blockquote>
<ol>
<li>查询处理器中的DML编译器会对用户提交的DML语句进行优化，并将其转换能够执行的底层数据库操作指令。</li>
<li>存储管理器中的缓冲区管理器负责将从磁盘读出的数据块放入内存缓冲区，同时也负责对缓冲区中的数据块进行维护。</li>
<li>查询处理器中的DDL编译器编译或解释用户提交的DDL语句，并将生成的元数据存储在数据库的数据字典中。</li>
<li>查询处理器中的查询执行引擎会会根据编译器产生的指令完成具体数据库数据访问功能。</li>
</ol>
</blockquote>
<p><strong>补充：</strong>DML数据操作语言，如：insert、update、delete;</p>
<p>​             DDL数据定义语言，如：create table、drop、alter;</p>
</li>
<li><p>触发器中<strong>inserted</strong>表用于存储insert和update语句所影响行的新值的副本，<strong>deleted</strong>表用于存储delete和update语句所影响行的旧值的副本。</p>
</li>
<li><p>关于SQL Server 2008中视图的说法：</p>
<blockquote>
<ol>
<li>数据库只存储标准视图的定义，并不存储标准视图的内容。</li>
<li>(*)如果在视图上创建了唯一聚集索引，则数据库中将保存该视图的内容。</li>
<li>索引视图引用的基本表必须与视图在同一个数据库中。</li>
</ol>
</blockquote>
</li>
<li><p>(*)关于索引视图的说法:</p>
<blockquote>
<ol>
<li>当很少对基表数据进行更改操作时，适合建立索引视图。</li>
<li>（*）索引视图的数据物理地保存在数据库中，因此建立索引视图会占用更多的存储空间</li>
<li>如果Group By列具有高基数度的数据聚合，则不适合建立索引视图。</li>
<li>对于经常执行连接和聚合操作的查询，适合建立索引视图。</li>
</ol>
</blockquote>
</li>
<li><p>关于SQL Server 2008 中guest用户的说法：</p>
<blockquote>
<ol>
<li>guest用户没有对应的登录账户名</li>
<li>通过授权语句可以启用数据库中的guest用户（默认为禁用状态）</li>
<li>所有数据库用户都<strong><u>不是</u></strong>继承该数据库中guest用户的权限</li>
<li>任何SQL Server 登录账户都可以访问启用了guest用户的数据库</li>
</ol>
</blockquote>
</li>
<li><p>（*）关于SQL Server 2008 身份验证模式的说法：</p>
<blockquote>
<ol>
<li>在<strong>Windows身份验证模式</strong>下，不允许 sa 登录到SQL Server服务器</li>
<li>不管是哪种身份验证模式，Windows中的Administrator无需授权就可登录到SQL Server服务器</li>
<li>安装好SQL Server之后，可以根据需要随时更改身份验证模式</li>
<li>在<strong>Windows身份验证模式</strong>下，<strong>所有Windows用户登录到SQL Server服务器都无需提供用户名和密码</strong>，但SQL Server会从用户登录到Windows时提供的用户名和密码<strong>查找当前用户信息</strong>，判断其是否是SQL Server的合法用户，不是，则拒绝登录。</li>
</ol>
</blockquote>
</li>
<li><p>关于数据库实施、运行和维护的说法中，最恰当的是</p>
<blockquote>
<p><strong>对于数据量极大的中大型系统，不需要等待所有的数据都入库后才开始试运行，可以先装载少量的数据，等到试运行的结果符合设计的要求后，再批量装入全部数据。</strong></p>
</blockquote>
</li>
<li><p>(<em>)设某数据库服务器中配置有2块300GB和1块500GB的硬盘，为了保证可靠性，数据库管理员在3块硬盘上建立了*</em>RAID5<strong>。建立了RAID5后，可用的磁盘空间为</strong>600GB**</p>
<blockquote>
<p><strong>Raid5需要3块硬盘（Raid 10需要4块），并把数据和相对应的奇偶校验信息存储到组成Raid5的各个磁盘上。其中任意 N-1 块磁盘上都存储完整数据，也就是说有相当于一块硬盘容量的空间用于存储奇偶校验信息。</strong></p>
</blockquote>
</li>
<li><p>（<em>）数据库的恢复顺序：*</em>1.恢复最近的完全数据库备份；2.恢复完全数据库备份之后的最近的差异数据库备份；3.按日志备份的先后顺序恢复自最近的完全或差异数据库备份之后的所有日志备份。**</p>
</li>
<li><p>（*）XML数据库是一种新型的数据库管理系统。下列关于XML数据库的说法：</p>
<blockquote>
<ol>
<li><p><strong>目前 XML数据库主要包括XEDB、NXD和 HXD三种类型。</strong></p>
</li>
<li><p><strong>很多关系数据库厂商在其传统的数据库产品中进行了扩充，使其能够处理XML文档</strong></p>
</li>
<li><p><strong>在数据库本身具有层次特征时，XML文档能够清晰地表达数据的层次特征。</strong></p>
</li>
<li><p>（错！）由于XML文档本身带有标记，可以自描述，因此XML数据库并不对XML文档进行解析。（<strong>解释：XML文档自身标记只是对本身的描述，需要数据库的解析才能达到真正用途</strong>）</p>
</li>
</ol>
</blockquote>
</li>
<li><p>下列关于分布式数据库和并行数据库的说法</p>
<blockquote>
<ol>
<li>（错）为了满足高并发业务的需要，共享内存结构的并行数据库比较适用于如银行出纳、民航售票等OLTP应用。（解析：OLTP应用需要进行大量的并行事务，因此若采用共享内存结构会引起大量数据冲突。）</li>
<li>（错）在分布式数据库的查询中，导致数据传输量大的主要原因是数据间的连接操作和<u>选择</u>操作。（解析：是连接操作和并操作。）</li>
<li>（对）<strong>如果数据分布不合理，并行数据库仅仅依靠多处理器，共享硬件资源等手段是无法实现真正意义上的并行处理的，也无法使其性能最优化。</strong></li>
<li>（错）与集中式数据库系统的事务相比，分布式数据库系统中只需要一个场地完成提交即可完成一个全局事务，这正是分布式数据库的优越之处。(解析：<strong>分布式数据库因为不同的分片和副本，因此很多时候在一个场地完成提交不能完成全局事务，如虽完成某片数据更新，却并没有完成全局数据更新。</strong>)</li>
</ol>
</blockquote>
</li>
</ol>
<h2 id="二、应用题-3"><a href="#二、应用题-3" class="headerlink" title="二、应用题"></a>二、应用题</h2><ol>
<li><p>数据库管理系统为用户和应用程序提供了<strong><u>DDL</u></strong>语言，用此语言可以定义数据库的模式结构，但此语言执行后的结果不能回滚。（<strong>DDL：数据库模式定义语言，用于描述数据库中要存储的现实世界实体的语言；DML：数据操纵语言，用户通过它可以实现对数据库的基本操作。</strong>）</p>
</li>
<li><p>当用户在一个关系表的某一列上建立一个非聚集索引（该表没有聚集索引）时，数据库管理系统会自动为该索引维护一个索引结构。该索引结构中的记录是由<strong><u>索引列列值</u></strong>和它相对的<strong>指针</strong>构成的。</p>
</li>
<li><p>在UML中，当要描述状态之间的转换时，可通过<strong><u>时间图</u></strong>来体现时间因子的作用。</p>
</li>
<li><p>（<em>）在SQL Server 2008中，能够出现在Select语句目标列中的用户自定义函数是*</em><u>标量</u><strong>函数。（</strong>SQL Server 2008 支持三种用户自定义函数：标量函数、内嵌表值函数和多语句表值函数。标量函数可以出现在select语句目标列中，其他两个函数必须放在select语句的from子句中。**）</p>
</li>
<li><p>（*）SQL Server 2008 中声明游标的语句为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Declare</span> vendor_cursor <span class="keyword">CURSOR</span> <span class="keyword">FOR</span></span><br><span class="line">SELECT...</span><br></pre></td></tr></table></figure>
</li>
<li><p>SQL Server 2008中设置 不允许用户获得对表的某种操作权限的命令为：Deny 对象权限名 ON {表名|视图} TO {数据库用户名|用户角色名}。</p>
</li>
<li><p>（<em>）在OLAP的实现方式中，以多维数据作为存储·结构的被称作 <u>*</em>M<strong></u>OLAP。（</strong>MOLAP称为基于多维库的OLAP，这种OLAP的核心是多维数据库技术。MOLAP工具以多维数据库的形式将元数据、基础事实数据和导出数据存储在以多维数组为基本存储结构的多维数据库中。**）</p>
</li>
</ol>
<h1 id="计算机三级数据库第五套题"><a href="#计算机三级数据库第五套题" class="headerlink" title="计算机三级数据库第五套题"></a>计算机三级数据库第五套题</h1><h2 id="一、选择题-4"><a href="#一、选择题-4" class="headerlink" title="一、选择题"></a>一、选择题</h2><ol>
<li><p><strong>建立数据仓库不是简单的把企业的各种应用集中在一起，而是利用企业信息系统生成的数据，<u>以面向主题、集成</u>的方式合理组织数据，解决数据分析应用和企业基本业务之间的性能冲突问题。</strong></p>
</li>
<li><p><strong>数据库应用系统设计</strong>需要考虑<strong>数据组织与存储</strong>、<strong>数据访问与处理</strong>、<strong>应用设计</strong>等几个方面。</p>
</li>
<li><p><strong>视图</strong>中<strong>可以使用</strong>order by 语句；<strong>子·查询语句</strong>中<strong>不能使用</strong>order by 语句。</p>
</li>
<li><p>优化查询的说法：</p>
<blockquote>
<ol>
<li><strong>避免或简化排序的目的是实现查询优化。</strong></li>
<li>在保证数据库一致性的前提下，将频繁操作的多个可以分割的处理过程放在一个存储过程中，这样可以大大提高系统的响应速度。（<strong>错</strong>）（<strong>解释</strong>：放在<strong>多个存储</strong>过程中，才可以提高系统的响应速度。）</li>
<li>使用<strong>游标</strong>会占用较多的系统资源，尤其对于大规模并发量的情况下，<strong>很容易使得系统资源耗尽而崩溃</strong>，而使用<strong>临时表</strong>能够<strong>加速查询。</strong></li>
<li><strong>相关子查询不可以加速查询。</strong></li>
</ol>
</blockquote>
</li>
<li><p>下列全部属于结构图的组图是</p>
<blockquote>
<p>类图、对象图、组件图、部署图、用例图。</p>
</blockquote>
<p><strong>结构图是指以模块调用关系为线索，用自上而下的连线表示调用关系并注明参数传递的方向和内容，从宏观上反应模块层次结构的图形。</strong></p>
</li>
<li><p>关系表与元组</p>
<blockquote>
<ol>
<li>关系表在逻辑上由一系列元组组成。</li>
<li>每个元组由多个属性组成。</li>
<li><strong>每个元组可以用数据库磁盘文件中的一个逻辑记录来存储</strong>。（<strong>记录包括多个域</strong>）</li>
<li><strong>元组的每个属性对应文件记录的一个域。</strong></li>
</ol>
</blockquote>
</li>
<li><p>ADO对象模型中，RecordSet对象的AddNew方法的功能是：<strong>在对应的数据库表中增加一条新记录。</strong></p>
<blockquote>
<p> RecordSet 对象<strong>用于操作来自提供者的数据</strong>。使用ADO时，<strong>通过RecordSet对象可对几乎所有数据进行操作</strong>，<strong>所有RecordSet对象均使用记录 (行) 字段 (列) 进行构造。</strong></p>
<p> <strong>RecordSet的常用方法为：</strong></p>
<ol>
<li>AddNew，创建一条新记录；</li>
<li>Cancel，撤销一次执行；</li>
<li>Close，关闭一个RecordSet；</li>
<li>Delete，删除一条记录或一组记录；</li>
<li>MoveNext，把记录指针移动到下一条记录。</li>
</ol>
</blockquote>
</li>
<li><p>属于优化SQL语句执行效率方法的有：</p>
<blockquote>
<ol>
<li>利用存储过程封装频繁使用的SQL语句。</li>
<li>不要随意使用游标</li>
<li>合理使用相关子查询</li>
</ol>
</blockquote>
</li>
<li><p>DBAS生命周期模型中时间最长的阶段是：<u><strong>运行管理与维护</strong></u>（是一个长久的过程，时间一般是以年为单位，其成本消耗也是巨大的）</p>
</li>
<li><p><strong>数据仓库</strong>不是用做日常查询，也不是汇总和统计，而<strong>主要用于提取数据中的潜在信息和知识。</strong></p>
</li>
<li><p><strong>数据挖掘采用适当的算法</strong>，从<strong>数据仓库</strong>的海量数据中<strong>提取具有潜在价值的信息和知识。</strong></p>
</li>
<li><p>（<em>）分布式数据库系统的“分片透明性”位于*</em><u>全局概念模式与分片模式之间</u>**。</p>
<blockquote>
<p><strong>分片透明性</strong>。<strong>用户编写程序只须对全局关系进行操作</strong>，不必考虑数据的分片及存储场地。<strong>当分片模式改变时，只须改变全局概念到分片模式的映象，而不会影响全局概念模式和应用程序，即实现了分片透明性</strong>。 </p>
</blockquote>
</li>
<li><p>（<em>）*</em>关于操作型数据和DSS(分析)型数据特征有如下说法:**</p>
<blockquote>
<ol>
<li>操作型数据更新频率高，DSS型数据一般不更新</li>
<li>操作型数据是详细的，DSS型数据是综合的</li>
<li>操作型数据处理需求先可知，DSS型数据处理需求事先不明确</li>
<li><strong>操作型数据对性能要求较高、无冗余</strong>。</li>
</ol>
</blockquote>
</li>
<li><p>一般而言，分布式数据库查询优化的首要目标是：<strong>使查询时通信代价最省</strong>。</p>
<blockquote>
<p>首先，通信代价较 I/O代价容易估计。其次，对于分布式数据库查询优化而言，<strong>通信代价比 I/O代价和CPU代价更为重要</strong></p>
</blockquote>
</li>
<li><p>关于事务调度：</p>
<blockquote>
<ol>
<li>调度分为<strong>串行调度</strong>和<strong>并发调度</strong>。</li>
<li><strong>串行调度</strong>的特点是<strong>一个事务的所有操作都执行完后才开始执行另一个事务</strong>。</li>
<li>多个事务的调度必须保持每个事务的操作在<strong>事务中的执行顺序不变</strong></li>
</ol>
</blockquote>
<p>事务的四大特性：①原子性 ②一致性 ③隔离性 ④持久性</p>
</li>
<li><p>事务日志用于保存：<strong>对数据的更新操作</strong>（它存储对数据进行的所有更改）</p>
</li>
</ol>
<h2 id="二、应用题-4"><a href="#二、应用题-4" class="headerlink" title="二、应用题"></a>二、应用题</h2><ol>
<li><p>数据库管理员要随时观察数据库的动态变化，并在数据库出现错误、故障或产生不适应的情况时能够随时采取有效措施保护数据库。这种监控机制称为<strong><u>手动监控机制</u></strong>。</p>
<blockquote>
<p>对数据库系统的监控分为<strong>手动监控机制和自动监控机制</strong>两种。</p>
</blockquote>
</li>
<li><p>在SQL中，用<strong><u>distinct</u></strong>关键词消除重复出现的元组。</p>
</li>
<li><p>事务是数据库执行的基本单位，如果一个事务执行成功，则全部更新提交；如果一个事务执行失败，则已做过的更新被恢复原状，好像整个事务从未执行过，这就是保持数据库处于<strong><u>一致性</u></strong>状态。</p>
</li>
<li><p>（<em>）数据仓库是一个面向主题的、集成的、时变的、非易失的数据集合，支持管理部门的决策过程，数据仓库通过数据转移从多个数据源提取数据，为了解决不同数据源格式上的不统一、需要进行的数据操作是*</em><u>转换</u>**。</p>
<blockquote>
<p><strong>数据转换</strong>的主要任务是对<strong>数据粒度以及不一致的数据进行转换</strong>。</p>
</blockquote>
</li>
<li><p>（<em>）如果数据库中的一个基本表中的数据量很少，且插入、删除、更新等操作频繁，该基本表最佳采用的文件结构是*</em><u>堆文件</u>**。</p>
<blockquote>
<p><strong>堆文件</strong>：也称为无序文件。在堆文件中，记录随机地存储在文件物理空间中，新插入的记录存储在文件的末尾。</p>
</blockquote>
</li>
<li><p>（<em>）在UML模型中，用于表达一系列的对象、对象间的联系以及对象间发送和接收消息的图是*</em><u>通信图或协作图</u>**。</p>
<blockquote>
<p><strong>在UML模型中，通信图是交互图的一种，也被称作协作图。它是表达对象之间的联系以及对象间发送和接收消息的图。</strong></p>
</blockquote>
</li>
</ol>
<h1 id="计算机三级数据库第六套题"><a href="#计算机三级数据库第六套题" class="headerlink" title="计算机三级数据库第六套题"></a>计算机三级数据库第六套题</h1><h2 id="一、选择题-5"><a href="#一、选择题-5" class="headerlink" title="一、选择题"></a>一、选择题</h2><ol>
<li><p><strong>DBAS需求分析</strong>阶段的性能分析是分析DBAS应具有的性能指标。</p>
<p><strong>其性能指标有</strong></p>
<blockquote>
<ol>
<li>数据操作响应时间，或数据访问响应时间；</li>
<li>系统吞吐量，即指系统在单位时间内可以完成的数据库事务或查询的数量；</li>
<li>允许并发访问最大用户数；</li>
<li>每TPS(price per TPS)代价值。</li>
</ol>
</blockquote>
</li>
<li><p>在信息系统的需求分析中，广为使用的DFD建模方法属于<strong><u> 分析方法</u></strong>。</p>
<blockquote>
<p>自顶向下的结构化分析法</p>
</blockquote>
</li>
<li><p>关于索引的说法</p>
<blockquote>
<ol>
<li>（<em>）*</em>聚集索引的键值可以重复**。</li>
<li>索引是<strong>典型的空间换取时间的方法</strong>，因此在设计索引时要在空间和时间两者之间进行权衡。</li>
<li>建立聚集索引时，数据库管理系统会按照聚集索引键值对数据进行排序。</li>
<li><strong>当经常进行范围查询时</strong>，在<strong>范围列上建立索引可以提高该类查询的效率</strong>。</li>
</ol>
</blockquote>
</li>
<li><p><strong>（*）不适合建立索引的情况</strong>：</p>
<blockquote>
<ol>
<li>查询中很少使用或参考的列不适合建立索引。</li>
<li>只有很少量数据的值也不适合建立索引。</li>
<li><strong>经常进行更新的列不适合建立索引</strong>。</li>
</ol>
</blockquote>
</li>
<li><p><strong>（*）适合建立索引的情况</strong>：</p>
<blockquote>
<ol>
<li><strong>经常需要搜索的列上</strong>，可以加快搜索的速度；</li>
<li><strong>在经常使用连接的列上（这些列主要是一些外键）</strong>可以加快连接速度，<strong>在经常需要根据范围进行索引的列上创建索引</strong>。因为索引已经排序，其指定的范围是连续的；</li>
<li><strong>在经常使用where子句的列上创建索引</strong>，加快条件的判断速度。</li>
</ol>
</blockquote>
</li>
<li><p>数据库概念设计是面向企业或组织中的数据需求的。下列是有关概念设计的说法：</p>
<blockquote>
<ol>
<li><strong>按照具有相同属性特征原则对客观事物进行分类</strong>，在分类的基础上概括命名，得到实体集。</li>
<li>从一个联系的两端（两个方向）确定实体集之间联系的基数，并把联系的基数标注在模型中。</li>
<li>要保证一个实体集中定义的<strong>每一个属性有意义、不重名</strong>。</li>
</ol>
<p><strong>（错误）</strong>分析和定义实体集中的每一个实例，并用有意义的符号或文字分别描述它们。<strong>（这是对实体集的命名）</strong></p>
</blockquote>
</li>
<li><p><u><strong>硬件容错</strong></u>最完全的方法是设计两套相同的数据库系统同时工作，数据的变化也同步，空间有一定的距离，<strong>因此同时破坏两套的概率几乎为零</strong>，这样就能达到数据库的完全安全。</p>
</li>
<li><p>（*）现有SQL Server 2008 数据库服务器，其中一个数据库占用80GB的空间，另有一台用于备份的计算机，该机器上有4个大小均为50GB的硬盘分区。若要将此数据库完全备份到该计算机上，则</p>
<blockquote>
<p><strong>可以先在每个分区上分别建立一个备份设备</strong>，指定每个设备的大小均为20GB，并建立一个包含这4个备份设备的<strong>备份媒体集</strong>，<strong>最后再用此备份媒体集备份数据库。</strong></p>
</blockquote>
</li>
<li><p>（<em>）数据库*</em>系统总体设计<strong>的主要内容包括</strong>确定DBAS体系结构<strong>、</strong>软硬件选型和配置设计<strong>、</strong>应用软件总体设计<strong>和</strong>业务规则初步设计**。</p>
</li>
<li><p>统一建模语言UML是一种常用于数据库系统设计和开发的可视化建模语言。关于UML，有下列说法：</p>
<blockquote>
<ol>
<li>UML中的<strong>视图是由一个或多个图组成的，一个图是系统模型中的某个侧面的展示</strong>。</li>
<li>用于描述系统的物理部署情况的是<strong>部署视图</strong>。</li>
<li><strong>类图和对象图都是UML的逻辑视图</strong>，用于描述系统在某个时间的静态结构。</li>
<li>在用例图中，与系统交互的人和其他实体<strong>都可以成为系统的角色</strong>。</li>
</ol>
</blockquote>
</li>
<li><p><strong>静态转储时</strong>，<strong>不能进行其他事务</strong>；<strong>动态转储时</strong>，<strong>允许并发操作</strong>，用户操作和转储操作同时进行，但<strong>会降低一致性</strong>。</p>
</li>
<li><p>（<em>）*</em>事务的四个性质**：</p>
<blockquote>
<ol>
<li><p><strong>原子性</strong>：描述的是<strong>事务中包括的诸多操作为了保持一致性要么都做，要么都不做</strong>。</p>
</li>
<li><p><strong>一致性</strong>：描述的是<strong>事务执行结果从一个一致性到另一个一致性的变化</strong>。</p>
</li>
<li><p><strong>隔离性</strong>：<strong>保证其并行结果的正确性</strong>。                                                                                          </p>
</li>
<li><p><strong>持久性</strong>：<strong>对数据库的改变时永久的</strong>，当事物提交后断电，<strong>结果不受影响</strong>。</p>
</li>
</ol>
</blockquote>
</li>
<li><p>（*）在分布式数据库应用系统中，对全局关系进行分片设计时，说法正确的是</p>
<blockquote>
<p><strong>对于一个全局关系中的任意数据</strong>，<strong>不允许其不属于任何一个片段</strong>，<strong>也不允许某些数据同时属于不同的片段</strong>。</p>
</blockquote>
<p><strong>（*）数据分片有以下三个原则：</strong></p>
<blockquote>
<ol>
<li><strong>完整性原则：</strong>即全局关系的<strong>所有数据项必须包含在某个片段中</strong>，<strong>否则将导致数据库不完整</strong>，<strong>造成某些片段数据丢失</strong>；</li>
<li><strong>重构性原则：</strong>即<strong>所有片段必须能够还原全局关系</strong>；</li>
<li><strong>不相交原则（对垂直分片的主键除外）：</strong>对于一个全局关系，要保证数据不丢失，则<strong>必须要属于某个片段</strong>，即<strong>不允许不属于任何一个片段</strong>，<strong>也不允许一个全局关系的某些数据既属于该全局关系的某些片段又属于该全局关系的另一个片段**</strong>（垂直关系中的码属性除外）**。</li>
</ol>
</blockquote>
</li>
<li><p>（*）关于OLTP和OLAP，有下列说法</p>
<blockquote>
<ol>
<li><p><strong>OLTP的安全性比OLAP要高，实施起来比较困难。</strong></p>
</li>
<li><p><strong>OLTP系统要求系统必须具有很高的响应速度，而OLAP对系统的响应速度较为宽松。</strong></p>
</li>
<li><p><strong>OLTP也称为面向交易的处理系统</strong>，实时处理数据，因此响应速度必须要很高。</p>
</li>
<li><p><strong>OLAP是数据仓库系统的主要应用</strong>，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。<strong>典型的应用就是复杂的动态的报表系统。</strong></p>
<p><strong>OLAP的特点一般有</strong>：<strong><u>实时性要求不是很高、数据量大、决策支持，查询动态，随时提出查询的要求。</u></strong></p>
</li>
</ol>
</blockquote>
</li>
<li><p>在超市所从事的信息活动中，<strong>属于挖掘时间序列模式的是：</strong><u><strong>针对注册用户，分析他们的购买，向他们设定下次可能购买的优惠规则。</strong></u></p>
<blockquote>
<p><strong>时间序列分析</strong>也可以称为<strong>数据演变分析</strong>，<strong>描述行为对象随时间变化的规律或趋势，并进行建模的数据挖掘方法。</strong></p>
</blockquote>
</li>
</ol>
<h2 id="二、应用题-5"><a href="#二、应用题-5" class="headerlink" title="二、应用题"></a>二、应用题</h2><ol>
<li><p>SQL Server中根据索引的实现方式，索引技术可以分成<strong>有序索引</strong>和<strong><u>散列索引</u></strong>两大类。</p>
</li>
<li><p>在分布式数据库中，使用<u><strong>分配模式</strong></u>来描述各片段到物理存放场地的映象。</p>
<blockquote>
<p><strong>分布式数据库总的数据分布策略</strong>可以从<strong>数据分片</strong>和<strong>数据分配</strong>两个角度来考虑，<strong>一般先数据分片，再数据分配</strong>。<strong>分片是对关系的操作，而分配是对分片结果的操作。</strong>分片模式是<strong>描述每个数据片断以及全局关系到片段的映象，</strong>分配模式是<strong>描述各片段到物理存放场地的映象。</strong></p>
</blockquote>
</li>
<li><p>在SQL Server 2008中，授予某数据库中的某个用户具有该数据库中全部用户数据表的插入、删除和修改权限，比较合理的做法是将该用户添加到系统提供的<strong><u>db_datawriter</u></strong>数据库角色中。</p>
</li>
<li><p>事务是由一系列操作组成的，事务的执行表现为事务中各个操作的执行。每个事务应具有结束操作。<strong>当一个事务发生故障需要终止并取消所有已执行的数据修改时应执行undo操作。</strong></p>
</li>
<li><p><strong>在数据仓库设计和建设过程中</strong>，设计者需要调查用户的决策或数据处理需求，并将功能相近需要相关数据支持的需求进行归类，得到不同的需求集合，并在企业数据模型中寻找能够满足各个需求集合的数据集合，然后针对各个数据集合开展数据仓库数据模型的设计。这种设计方法称为<strong><u>面向主题</u></strong>的设计方法。</p>
</li>
<li><p>（<em>）OLAP主要用于支持复杂的分析操作， 侧重对决策人员和高层管理人员的数据支持。*</em>OLAP的实现方式主要由三种：**</p>
<blockquote>
<ol>
<li><strong>MOLAP：基于多维数据库</strong></li>
<li><strong>HOLAP：基于混合型数据库</strong></li>
<li><strong>ROLAP：基于关系型数据库</strong></li>
</ol>
</blockquote>
</li>
</ol>
<h1 id="计算机三级数据库第七套题"><a href="#计算机三级数据库第七套题" class="headerlink" title="计算机三级数据库第七套题"></a>计算机三级数据库第七套题</h1><h2 id="一、选择题-6"><a href="#一、选择题-6" class="headerlink" title="一、选择题"></a>一、选择题</h2><ol>
<li>数据库应用系统<strong>逻辑设计阶段</strong>有：</li>
</ol>
<blockquote>
<ol>
<li>数据库逻辑结构设计</li>
<li>数据库事务概要设计</li>
<li>应用程序概要设计</li>
</ol>
</blockquote>
<blockquote>
<p><strong>系统总体框架</strong>设计属于<strong>概念设计</strong></p>
</blockquote>
<ol start="2">
<li>数据库概念设计的目标：</li>
</ol>
<blockquote>
<ol>
<li>定义和描述应用领域涉及的数据范围</li>
<li>获取应用领域或问题域的信息模型</li>
<li>描述清楚数据的属性特征</li>
<li>描述清楚数据之间的关系</li>
<li>定义和描述数据的约束</li>
<li>说明数据的安全性要求</li>
<li>支持用户的各种数据处理需求</li>
<li>保证信息模型方便地转换成数据的逻辑结构（数据库模式），同时也便于用户理解</li>
</ol>
</blockquote>
<ol start="3">
<li>在数据库应用系统设计中，如果事务中存在和用户的长时间交互，它会带来哪些坏处</li>
</ol>
<blockquote>
<ol>
<li>降低系统的并发度</li>
<li>增加死锁的数量</li>
<li><strong>影响检查点的效果</strong></li>
</ol>
</blockquote>
<blockquote>
<p><strong>事务是并发控制的基本单位。所谓事务，它是一个操作序列。</strong></p>
<p><strong>系统在执行检查点操作时，所有的事务处理都被暂时中止，长时间的事务影响检查点的效果。</strong></p>
</blockquote>
<ol start="4">
<li><p>不同的数据库管理系统<strong>有着不同的逻辑实现结构</strong>，因此数据库空间管理办法随数据库管理系统不同而不同</p>
</li>
<li><p>属于<strong>物理设计</strong>的是：</p>
<blockquote>
<ol>
<li>文件组织与存取设计</li>
<li>数据分布设计</li>
<li>确定数据库和操作系统参数</li>
<li>从时间、空间、维护代价等方面评估物理设计结果，并将评估后的结果实施到数据库中</li>
</ol>
</blockquote>
</li>
</ol>
<blockquote>
<p>（<strong>不属于物理设计</strong>）将关系模式和相关视图转换为特定数据库管理系统的可支持的表和视图</p>
</blockquote>
<ol start="6">
<li><p>（<em>）从功能上讲，*</em>数据库应用系统设计<strong>包括下列四个层次，其中包括构件设计的是<u></strong>业务逻辑层**</u></p>
<blockquote>
<ol>
<li><strong>表示层</strong>，位于最外层，离用户最近，用于显示数据和接受用户输入的数据。</li>
<li><strong>业务逻辑层</strong>，表示层和数据访问层之间通信的桥梁，主要负责数据的传递和处理，例如数据有效性的检验、业务逻辑描述相关功能。业务逻辑层概要设计包括：结构、行为、数据接口、故障处理、安全设计、系统维护与保障等方面的内容。</li>
<li><strong>数据访问层</strong>，主要实现数据的保存和读取操作。</li>
<li><strong>数据持久层</strong>。</li>
</ol>
</blockquote>
</li>
</ol>
<blockquote>
<p>综上所述，<strong>业务逻辑层的主要任务是梳理DBAS的各项业务活动</strong>，将其表示为各种系统构件（如：类、模块、组件等），因此<strong>构件属于业务逻辑层</strong>。</p>
</blockquote>
<ol start="7">
<li><p>不同的数据库产品提供不同的应用程序接口、因此在更换数据库产品后，<strong>一般原有的应用程序和数据库接口会失效</strong>，<strong>需要重新修改应用程序</strong>。</p>
</li>
<li><p><strong>关于分布式数据库</strong>：</p>
<blockquote>
<ol>
<li>分布式数据库的事务管理包括<strong>恢复控制和并发控制</strong>，<strong>恢复控制一般采用的策略是基于两阶段的提交协议</strong>。</li>
<li><strong>分布式数据库系统的目标是高性能和高可用性</strong>，通过多个处理节点并行执行数据库任务，提高整个数据库系统的性能和可用性。</li>
</ol>
</blockquote>
</li>
<li><p>（<em>）若有算法A，能根据用户间的相似性，将客户集合划分成k个子集合，并使属于同一个子集合的客户间的相似性尽可能大，不属于同一子集合的客户间的相似性尽可能小。则算法A属于一种*</em><u>聚类算法</u>**。</p>
<blockquote>
<p><strong>关联分析算法</strong>（计算支持度和置信度）</p>
<p><strong>分类算法</strong>（事先知道有哪些种类可分）</p>
<p><strong>回归预测法</strong>（是在分析市场现象<a href="https://baike.baidu.com/item/自变量/6895256" target="_blank" rel="noopener">自变量</a>和<a href="https://baike.baidu.com/item/因变量" target="_blank" rel="noopener">因变量</a>之间相关关系的基础上，建立变量之间的<a href="https://baike.baidu.com/item/回归方程/11042494" target="_blank" rel="noopener">回归方程</a>，并将回归方程作为<a href="https://baike.baidu.com/item/预测模型/2488641" target="_blank" rel="noopener">预测模型</a>，根据<a href="https://baike.baidu.com/item/自变量/6895256" target="_blank" rel="noopener">自变量</a>在预测期的数量变化来预测因变量关系大多表现为相关关系，因此，回归分析预测法是一种重要的<a href="https://baike.baidu.com/item/市场预测/3217035" target="_blank" rel="noopener">市场预测</a>方法。）</p>
</blockquote>
</li>
<li><p>物化视图将会预先计算并保存耗时操作的结果，可大幅度提高查询效率，<strong>物化视图可人工手动刷新和自动定时刷新</strong>。</p>
</li>
<li><p>（<em>）ODS（Operation Data Store）是数据仓库体系结构中的一个可选部分，ODS具备数据仓库的部分特征和OLTP系统的部分特征，它是“*</em><u>面向主题的、集成的、当前或接近当前的、不断变化的</u>**”数据。</p>
<blockquote>
<p><strong>第一类</strong>ODS数据更新频率是<strong>秒级</strong></p>
<p><strong>第二类</strong>ODS数据更新频率是<strong>小时级</strong></p>
<p><strong>第三类</strong>ODS数据更新频率是<strong>天级</strong></p>
<p>上述三类是根据数据更新的速度划分的</p>
<p><strong>第四类</strong>ODS是根据数据<strong>来源方向和类型划分的</strong></p>
</blockquote>
</li>
<li><p>（<em>）用于*</em>数据库完整性保护**的是</p>
<blockquote>
<p><strong>创建触发器</strong></p>
<p><strong>定义事务隔离性级别</strong></p>
</blockquote>
<p><strong>数据库的完整性是指数据库中数据的正确性、一致性和相容性。</strong></p>
<p>不用于</p>
<blockquote>
<p><strong>数字签名</strong>：防止数据篡改</p>
<p><strong>定义主码</strong>：实体完整性</p>
</blockquote>
</li>
<li><p>UML的几种图介绍</p>
<blockquote>
<ol>
<li><strong>协作图</strong>：主要用于描述对象在空间中如何交互，即除了动态交互，也直接描述了对象是如何链接在一起的情形</li>
<li><strong>状态图</strong>：主要用于描述一个对象在其生存期间的动态行为，表现为一个对象所经历的状态序列，引起状态转移的事件，以及因状态转移而伴随的动作。一般可以用状态机对一个对象的生命周期建模，状态图用于显示状态机，重点在与描述状态图的控制流。</li>
<li><strong>顺序图</strong>：主要用于描述指定的一组对象是如何交互的，它着眼于消息队列，也就是在消息间如何发送和接收消息。</li>
<li><strong>部署图</strong>：描述的是系统运行时的结构，展示了硬件的配置及其软件如何部署到网络结构中。<strong>一个系统模型只有一个部署图，部署图通常用来帮助理解分布式系统</strong>。</li>
</ol>
</blockquote>
</li>
<li><p><strong>数据库管理员的职责</strong></p>
<blockquote>
<ol>
<li><strong>数据库的转储和恢复</strong></li>
<li><strong>数据库安全性、完整性控制</strong></li>
<li><strong>数据库性能的检测和改善</strong></li>
<li><strong>数据库的重组和重构</strong></li>
</ol>
</blockquote>
</li>
<li><p><strong>所有登陆名都属于public服务器角色</strong>，登陆名是不能移除public角色的，且public角色是不能删除的。</p>
</li>
<li><p>触发器是一种特殊的存储过程，它是由用户对数据的更改操作自动引发执行的。<strong>适于触发器实现的数据库控制</strong>是<u><strong>完整性控制</strong></u>。</p>
<blockquote>
<p>触发器通常用于保证业务规则和数据完整性，其主要优点是用户可以用编程的方法来实现复杂的处理逻辑和业务规则，增强了数据完整性约束的功能。</p>
</blockquote>
</li>
<li><p>频繁使用关联查询，最适合用<strong><u>聚集文件</u></strong>保存</p>
<blockquote>
<ol>
<li>聚集文件是一种具有多种记录类型文件，存储了来自多个关系表的数据，每个关系表对应文件中的一种记录类型；</li>
<li>数据库中数据量效大时，对数据库查询需要多次访问磁盘文件，严重影响性能指标，为了降低多表操作时的磁盘访问次数，提高多表查询速度，可采用聚集文件;</li>
<li>聚集文件将不同关系表中有关联关系的记录存储在同一磁盘块内，从而减少多表查询时磁盘块的访问次数，提高系统I/O速度和查找处理速度;　</li>
</ol>
</blockquote>
</li>
<li><p>关于SQL Server2008中游标的说法</p>
<blockquote>
<ol>
<li>每个游标都有一个当前行指针，<strong>当游标打开后，当前行指针自动指向结果集的第一行数据</strong></li>
<li>如果在声明游标时未指定<strong>insensitive</strong>选项，则已经提交的对基表的更新都会反映在后面的提取操作中。（<strong>insensitive关键字用于创建由游标使用的临时副本</strong>）</li>
<li>当<strong>@@FETCH_STATUS=0</strong>时，<strong>表示FETCH语句成功</strong>；当<strong>@@FETCH_STATUS=-1</strong>时，<strong>表示FETCH语句失败或行不在结果集中</strong>；<strong>@@FETCH_STATUS=-2时</strong>，<strong>表示提取的行不存在</strong></li>
<li><strong>关闭游标后。可以通过OPEN语句再次打开该游标</strong></li>
</ol>
</blockquote>
</li>
<li><p><strong>关于日志备份</strong></p>
<blockquote>
<p>日志备份<strong>仅备份日志，不备份数据</strong></p>
<p>日志备份的<strong>执行效率通常比差异备份和完整备份高</strong></p>
<p>第一次对数据库进行的备份<strong>必须是完整备份</strong></p>
<p>日志备份的<strong>时间间隔通常比差异备份短</strong></p>
</blockquote>
</li>
<li><p>关于内联(内嵌)表值函数</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--语法格式</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> 函数名(参数)</span><br><span class="line"><span class="keyword">returns</span> <span class="keyword">table</span></span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">return</span>(<span class="keyword">select</span>语句)</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>在内联表值函数中，没有相关联的返回变量</li>
<li>（<strong>错</strong>）内联表值函数通过insert语句填充函数返回的表值 （<strong>用select语句填充</strong>）</li>
<li>内联表值函数的作用类似于带参数的视图</li>
<li>调用内联表值函数时，只能将内联表值函数放置在from子句中（select * from 函数名）</li>
</ol>
</blockquote>
</li>
<li><p><strong>适合建立索引</strong></p>
<blockquote>
<p><strong>经常执行查询操作并且数据量很大的表</strong></p>
<p><strong>经常出现在where子句、order by子句、group by子句中的</strong></p>
</blockquote>
<p><strong>前后都是%的列查询不会访问索引，不适合建立索引</strong></p>
</li>
<li><p>在云计算中，<strong>当云以即用即付的方式提供给公众</strong>的时候，我们称其为<strong><u>公共云</u></strong></p>
</li>
</ol>
<blockquote>
<p><strong>私有云</strong>：<strong>不对公众开放的企业或组织内部数据中心的资源</strong>。</p>
</blockquote>
<h2 id="二、应用题-6"><a href="#二、应用题-6" class="headerlink" title="二、应用题"></a>二、应用题</h2><ol>
<li><p>（<em>）具体来说，UML的语义是定义在一个*</em>四层模型概念框架**中的，这四层分别是：</p>
<blockquote>
<ol>
<li><strong>元元模型层</strong></li>
<li><strong>元模型层</strong></li>
<li><strong>模型层</strong></li>
<li><strong>用户模型层</strong></li>
</ol>
</blockquote>
</li>
<li><p>（<em>）在UML中，*</em><u>聚集</u>** 是一种特殊形式的关联。它表示类之间的关系是整体与部分的关系。</p>
</li>
<li><p>（<em>）在衡量数据库应用系统的性能指标中，*</em><u>数据吞吐量</u>**指的是系统在单位时间内可以完成的数据库事务数量。</p>
</li>
<li><p>（<em>）Google的云数据库是一个分布式的结构化数据存储系统，称作：*</em><u>Bigtable</u>**。</p>
</li>
<li><p>（<em>）知识发现主要由三个步骤组成，它们是<u>*</em>数据准备<strong></u>、<u></strong>数据挖掘<strong></u>、<u></strong>结果的解释评估**</u>。</p>
<blockquote>
<p><strong>知识发现</strong>指的是<strong>从数据集中识别出有效的、新颖的、潜在有用的以及最终可理解的模式的非平凡过程</strong>。</p>
<p>知识发现将信息变为知识，从数据矿山中找到蕴藏的知识金块，将为知识创新和知识经济的发展作出贡献，</p>
<p><strong>也是所谓“数据挖掘”的一种更为广义的说法</strong>。</p>
</blockquote>
</li>
<li><p>（<em>）在SQL Server2008，主要数据文件必须建立在*</em><u>主</u>** <strong>文件组中</strong>。</p>
<blockquote>
<p><strong>每个数据库有一个主要数据文件和若干个从文件</strong>。<strong>文件是数据库的物理体现</strong>。文件组可以包括分布在多个逻辑分区的文件，从而实现负载均衡，它允许对文件进行分组，以便于管理和数据的分配及放置。<strong>主文件组包含主要数据文件组和任何没有明确指派给其他文件组的其他文件</strong>。</p>
</blockquote>
</li>
<li><p>在分布式数据库中，如果用户编写程序时不必了解数据分片在各个场地的<u>分配情况</u>，则称为该分布式数据库系统具有<strong><u>位置</u></strong> <strong>透明性</strong>。</p>
</li>
<li><p>不同的数据库管理系统采用的日志文件格式不完全一样，概括起来主要有以<strong><u>记录为单位的日志文件</u></strong>和以<strong><u>数据块为单位的日志文件</u></strong>两种。</p>
</li>
</ol>
<h1 id="计算机三级数据库第八套题"><a href="#计算机三级数据库第八套题" class="headerlink" title="计算机三级数据库第八套题"></a>计算机三级数据库第八套题</h1><h2 id="一、选择题-7"><a href="#一、选择题-7" class="headerlink" title="一、选择题"></a>一、选择题</h2><ol>
<li><p>在划分关系模型时，<strong>一对一和一对多的关系可以合并到其他实体集中</strong>，<strong>多对多作为一个单独的实体集</strong>。</p>
</li>
<li><p>（<em>）*</em>双机热备<strong>（active-standby）：属于</strong>数据库恢复技术内容**，当介质被破坏后能够保证数据的完整性。</p>
</li>
<li><p>几种文件结构的概述：</p>
<blockquote>
<ol>
<li><p><strong>散列文件</strong>：利用散列存储方式组织的文件，亦称为直接存取文件。</p>
<p><strong>散列文件的优点</strong>：文件随机存放，记录不需进行排序；<strong>插入删除方便</strong>；<strong>存取速度快</strong>；不需要索引区，节省空间。</p>
<p><strong>散列文件的缺点</strong>：<strong>不能进行顺序存取</strong>，<strong>只能按关键字随机存取</strong>，且询问方式只限于简单询问，并且多次插入删除后，也可能造成文件结构不合理，需要重新组织文件。</p>
</li>
<li><p><strong>堆文件</strong>：也称为无序文件。在堆文件中，记录随机地存储在文件物理空间中，新插入的记录存储在文件的末尾。因为堆文件无需建立索引，维护代价非常低。<strong>虽然堆文件的数据访问效率较低，但数据量很少时，定位文件记录的时间非常短</strong>。</p>
</li>
<li><p><strong>顺序文件</strong>：文件信息存放在若干连续的物理块中。<strong>其优点</strong>是简单、支持顺序存取和随机存取速度相对较快。<strong>缺点</strong>是文件不能动态增长、<strong>不利于文件插入和删除</strong>。<strong><u>如果用户的查询定义在查找码上，则顺序文件是比较合适的文件结构</u></strong>。</p>
</li>
<li><p><strong>聚集文件</strong>：聚集文件将不同关系表中有关联关系的记录存储在一起。<strong><u>如果某些重要而频繁的用户查询经常需要进行多表连接操作，可以考虑聚集文件，来改善查询效率。</u></strong></p>
</li>
</ol>
</blockquote>
</li>
<li><p>有效减少数据库死锁发生数量的方法有</p>
<blockquote>
<ol>
<li><strong>各个事务应顺序访问共享资源</strong>。</li>
<li><strong>将各个复杂的、大的事务分解成多个简单、小的事务</strong>。（不能合并事务）</li>
<li><strong>按同一顺序访问对象</strong>。</li>
<li><strong>事务隔离性级别</strong>。</li>
<li><strong>使用绑定连接</strong>。</li>
<li><strong>灵活使用显示加速技术</strong>。</li>
</ol>
</blockquote>
</li>
<li><p>UML<strong>活动图</strong>主<u>要用于描述系统、用例和程序模块中逻辑流程的先后执行次序或并行次序</u>。</p>
</li>
<li><p>SET赋值语句给变量赋值且一个变量只有一个值。当值可能有多个时，不能用SET</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">--max()可能有多个值</span></span><br><span class="line"><span class="keyword">SET</span> @x=<span class="keyword">select</span> <span class="keyword">max</span>(工资) <span class="keyword">from</span> 职工表 <span class="keyword">where</span> 所在部门=@dept</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p>关于SQL server 2008 数据库文件的说法</p>
<blockquote>
<ol>
<li><strong>一个数据库只能有一个主要数据文件</strong>，但可以有多个次要数据文件。</li>
<li><strong>一个数据文件不能属于多个文件组</strong>。</li>
<li><u><strong>日志文件不能包含在文件组中</strong></u>。</li>
<li><strong>一个数据库可以包含多个日志文件</strong>。</li>
</ol>
</blockquote>
</li>
<li><p>关于SQL server 2008 分区表的说法</p>
<blockquote>
<ol>
<li>分区表是从物理上将一个表划分为若干个分区。</li>
<li><strong>分区后的各分区存储在数据库中一个或多个文件组中</strong>。（不需要一定放在不同的文件组中；<strong>通过元数据来表述数据存储的逻辑地址</strong>）</li>
<li><strong>表中数据量的大小并不是是否需要进行分区的唯一考虑因素</strong>。</li>
<li><strong>对表进行分区后，用户在访问数据时不需要知道被访问数据所在的分区</strong>。</li>
</ol>
</blockquote>
</li>
<li><p>关于<strong>存取控制</strong>的说法：</p>
<blockquote>
<ol>
<li>自主存取控制主要通过GRANT、REVOKE、DENY语句来实现</li>
<li>在强制存取控制中，DBMS将实体划分为<strong>主体和客体两大类</strong></li>
<li>仅当主体的许可性级别<strong><u>大于或等于</u></strong>客体的密级时，<strong>主体才能读取相应的客体</strong>；<strong>仅当</strong>主体的许可性级别<strong><u>等于</u></strong>客体的密级时，<strong>主体才能<u>写</u>相应的客体</strong></li>
<li>强制存取控制本质上是分层次的，它比自主存取控制更严格</li>
</ol>
</blockquote>
</li>
<li><p>关于数据库的<strong><u>重组和重构</u></strong>：</p>
<blockquote>
<p><strong><u>数据库的重组并不修改原设计的逻辑和物理结构</u></strong>，而<strong><u>数据库的重构则要部分的修改数据库的模式和内模式</u></strong></p>
</blockquote>
</li>
<li><p>关于数据库中的索引：</p>
<blockquote>
<ol>
<li>在某个查询中带排序的属性有多个时可以考虑在这些属性上建立<strong>复合索引</strong></li>
<li>一个表中最多<strong>只能有一个</strong> <strong>主索引或聚集索引</strong></li>
<li>（<em>）*</em>多属性索引<strong>中，索引属性的顺序一般</strong>按照其区分度进行排序**</li>
<li><strong>B树索引一般适用于等值和范围查询</strong></li>
<li><strong>散列索引不能用于<u>范围查询</u></strong> (检索速度快)</li>
</ol>
</blockquote>
</li>
<li><p>有运行于两个地点的分布式数据库，需要对两个分布在两地数据量很大的表进行连接操作，这两张表数据变化很慢，为了提高查询速度，可行的方法是 <strong><u>将两张表复制交叉复制到两地</u></strong></p>
<blockquote>
<p><strong>分布式数据库传输代价计算</strong>：</p>
<p>（<em>）*</em>传输代价=I/O代价+CPU代价+通信代价**</p>
<p><strong>优先使通信代价最省</strong>，将两张表交叉复制到两地可以省去通信代价</p>
</blockquote>
</li>
<li><p>（<em>）*</em>检查点**能减少数据库完全恢复时所必须执行的日志，提高数据库恢复速度。关于检查点的说法</p>
<blockquote>
<ol>
<li>检查点记录的内容包括<strong>建立检查点时正在执行的事务清单</strong>和<strong>这些事务最近一个日志记录的地址</strong></li>
<li>在检查点建立的<strong>同时</strong>，数据库管理系统会将<strong>当前数据缓冲区中的所有数据记录写入数据库中</strong></li>
<li>（<em>）*</em>检查点由数据库恢复子系统定时或不定时的建立，而不是由管理员手动建立**</li>
<li>使用检查点进行恢复时<strong>需要从“重新开始文件”中找到最后一个检查点记录在日志文件中的地址</strong></li>
</ol>
</blockquote>
</li>
<li><p>有关Active-Standby（双机热备）模式服务器容错技术的说法</p>
<blockquote>
<ol>
<li>此模式需要<strong>两台服务器使用共享的存储设备</strong>，数据库中数据需要存储在此设备中</li>
<li>此模式需要在<strong>两台服务器之间建立专用的状态检测网络</strong></li>
<li>此模式中<strong>增加串口方式检测服务器状态</strong>的可以<strong>有助于避免“脑裂”现象出现</strong> <a href="https://blog.csdn.net/lgstudyvc/article/details/48296651" target="_blank" rel="noopener">什么是脑裂？</a></li>
<li>此模式可以保证在<strong>Active服务器出现故障时</strong>，<strong>在最短时间内恢复使用</strong></li>
</ol>
</blockquote>
</li>
<li><p>Active-Active（双主机）指两种不同业务分别在两台服务器上互为主备状态（即Active-Standby和Standby-Active状态），<strong>优点是两台服务器切换速度快，数据库连接不中断，应用不受影响</strong></p>
</li>
<li><p>SQL Server2008提供了<strong>三种恢复模式</strong>，不同的恢复模式决定了数据库支持的备份类型和还原方案。关于恢复模式的说法</p>
<blockquote>
<ol>
<li><strong>简单恢复模式</strong>不记录事务日志，<strong>如果数据库损坏</strong>，简单恢复模式<strong>可能造成数据丢失</strong></li>
<li><strong>完整恢复模式</strong>记录所有事务日志，<strong>同时事务日志记录保留到对其备份完毕为止</strong></li>
<li><strong>大容量日志恢复模式</strong>只对<strong>大容量操作进行最小记录</strong>，<strong>使事务日志不会被大容量加载操作所填充</strong></li>
<li><strong>大容量日志恢复模式不支持时点恢复，也不支持还原单个数据页</strong></li>
</ol>
</blockquote>
</li>
<li><p>SQL Server2008三种恢复模式的详细描述</p>
<blockquote>
<ol>
<li><p><strong>简单恢复</strong>：<strong>无日志备份</strong>。自动回收日志空间以减少空间需求，实际上不再需要管理事务日志空间。最新备份之后的更改不受保护。发生灾难时，这些更改必须重做。只能恢复到备份的结尾。</p>
</li>
<li><p><strong>完整恢复</strong>：<strong>需要日志备份</strong>。数据文件丢失或损坏不会导致数据库系统丢失工作。<strong>可以恢复到任意时点</strong>（例如应用程序或用户错误之前）。<strong>完整恢复模式还支持还原单个数据页</strong>。</p>
</li>
<li><p><strong>大容量日志恢复</strong>：<strong>需要日志备份</strong>。<strong><u>是完整恢复模式的附加模式</u></strong>，<strong>允许执行高性能的大容量复制操作</strong>。通过使用最小方式记录大规模大容量操作，减少日志空间使用量。</p>
<p>如果在最新日志备份后发生日志损坏或执行大容量日志记录操作，则必须重做自上次备份之后所做的更改，否则将丢失所有工作，<strong>可以恢复到任何备份的结尾并且不支持时点恢复和还原单个数据页</strong>。</p>
</li>
</ol>
</blockquote>
</li>
<li><p>SQL Server2008<strong>支持多种数据库还原级别</strong>。下列有关其数据库恢复的说法</p>
<blockquote>
<ol>
<li>在进行数据库整体还原和恢复过程中，此<strong>数据库处于脱机状态</strong></li>
<li>（<em>）SQL Server *</em>支持对数据库的一个数据文件进行还原<strong>，</strong>在还原过程中数据库(此文件)属于脱机状态<strong>，</strong>其他的文件都不能进行读写操作，因而其他文件也会受到影响**</li>
<li>在还原数据库之前，如果数据库的日志没有损坏，<strong>为了减少数据丢失可以进行一次尾部日志备份</strong></li>
<li>（<em>）*</em>在进行数据库还原的过程中可以将数据库移动到其他位置**</li>
</ol>
</blockquote>
</li>
<li><p><strong>快照</strong>：该方法通过对当前数据表进行“照相”，记录当前的数据表信息“相片”，然后将当前的“相片”与以前的数据表“相片”进行比较，如果不一致将通过一定的方法传到数据仓库，从而实现数据的一致性，<strong>此种方式适合于更新频率较低的数据表</strong>。</p>
</li>
</ol>
<h2 id="二、应用题-7"><a href="#二、应用题-7" class="headerlink" title="二、应用题"></a>二、应用题</h2><ol>
<li><p>每TPS代价值是用于衡量系统<strong><u>性价</u></strong>比的指标。（性能价格）</p>
</li>
<li><p>DFD方法由四种基本元素构成：<strong><u>数据流、数据处理、数据存储和外部项</u></strong>。</p>
</li>
<li><p>（<em>）UML中的*</em><u>活动图</u><strong>的主要作用是陈述活动与活动之间流程控制的转移，其作用类似于流程图，然而与流程图不同的是</strong>其支持并行行为**。</p>
</li>
<li><p>（<em>）设有学生表（学号、姓名、所在系）和选课表（学号、课程号、成绩），现要使用*</em>开窗函数**查询每个学生的姓名、所在系及选课门数（不包括没选课的学生）。请补全下列语句：</p>
<p>SELECT DISTINCT 姓名，所在系，COUNT(<em>)  *</em><u>OVER (PARTITION BY T1.学号)  OVER (PARTITION BY T2.学号)</u>**  AS 选课门数 FROM 学生表 T1 JOIN 选课表 T2 ON T1.学号=T2.学号。</p>
<blockquote>
<p>开窗函数公式：<strong><u>函数名(列) OVER(选项)。OVER关键字表示把函数当成开窗函数而不是聚合函数</u></strong>。SQL Server 2005/2008 支持两种开窗函数，分别为：<strong>排名开窗函数和聚合开窗函数</strong>。<strong><u>聚合开窗函数只能使用PARTITION BY 子句不带任何语句</u></strong>，<strong>ORDER BY 不能与聚合开窗函数一同使用</strong>。<strong>很多聚合函数都可以用作开窗函数的运算，如SUN、AVG、MAX、MIN和COUNT。</strong></p>
</blockquote>
<blockquote>
<p><strong>开窗函数简介</strong>:与聚合函数一样，开窗函数也是对行集组进行聚合计算，但是它不像普通聚合函数那样每组只返回一个值，<strong>开窗函数可以为每组返回多个值</strong>，因为开窗函数所执行聚合计</p>
<p>算的行集组是窗口。在 ISO SQL 规定了这样的函数为开窗函数，在 Oracle 中则被称为分析函数。</p>
</blockquote>
</li>
<li><p>新增汇总表的调优方法是一种以<u>空间换<strong>时间</strong></u>的调优方法。</p>
</li>
<li><p>（<em>）分布式数据库中，混合分片是水平分片、垂直分片和<u>*</em>导出**分片</u>的混合。</p>
<blockquote>
<p><strong>分布式数据库分片类型</strong>有如下几种：</p>
<ol>
<li><strong>水平分片</strong>：按一定的条件把全局关系的所有元组划分成若干不相交的子集，每个子集都是关系的一个片段。</li>
<li><strong>垂直分片</strong>：把一个全局关系的属性集分成若干个子集，并在这些子集上作投影运算，每个投影称为垂直分片。</li>
<li><strong>导出分片</strong>：又称为导出水平分片，即水平分片的条件不是本关系属性的条件，而是其他关系属性的条件。</li>
<li><strong>混合分片</strong>：以上三种方法的混合。可以先水平分片在垂直分片，或先垂直分片再水平分片，或其他形式的分片，但他们的结果是不相同的。</li>
</ol>
</blockquote>
</li>
<li><p>（<em>）在T-SQL中，提取cur1游标中<u>相对于当前行</u>向下第5行数据的语句是 FETCH *</em><u>relative</u>** 5 FROM cur1…</p>
<blockquote>
<p>其他可选参数：</p>
<p><strong>NEXT</strong>：返回紧跟当前行之后的数据行，并且当前行递增为结果行。</p>
<p><strong>PRIOR</strong>：返回紧跟当前行之前的数据行，并且当前行递减为结果行。</p>
<p><strong>FIRST</strong>：返回游标中的第一行并将其作为当前行。</p>
<p><strong>LAST</strong>：返回游标中的最后一行并将其作为当前行。</p>
<p><strong>ABSOLUTE {n|@nvar}</strong>：如果n或@nvar为正数，则返回从游标第一行开始向后的第n行，并将返回行变成新的当前行。如果n或@nvar为负数，则返回从游标第一行开始之前的第n行，并将返回行变成新的当前行。<strong>如果n或@nvar为0则不返回任何结果</strong>。n必须是正数常量,并且@nvar的数据类型必须为smallint、tinyint或int。</p>
<p><strong>RELATIVE {n|@nvar}</strong>：和absolute类似 不过relative是以当前行为起点。<strong>如果n或@nvar为0，则返回当前行</strong>。<strong>在对游标进行第一次提取时，如果在将n或@nvar设置为负数或0的情况下指定FETCH RELATIVE，则不返回任何行</strong>。</p>
</blockquote>
</li>
<li><p>（<em>）数据挖掘方法中，*</em><u>关联规则</u>**挖掘就是用于发现数据库中数据间的关联性的。</p>
<blockquote>
<p>其他挖掘方法还有：<strong>分类、回归分析、聚类、关联规则、特征、变化和偏差分析、Web页挖掘</strong></p>
</blockquote>
</li>
</ol>
<h1 id="随手记（综合）"><a href="#随手记（综合）" class="headerlink" title="随手记（综合）"></a>随手记（综合）</h1><ol>
<li><p><strong>顺序图</strong>强调的是时间，通信图强调的是空间。</p>
</li>
<li><p><strong>状态图</strong>中只能有一个起始状态，可以有多个结束状态。</p>
</li>
<li><p>类图（静态结构）、顺序图、通信图（动态结构）都属于系统结构图。</p>
</li>
<li><p><strong>用例模型由 用例、角色、系统3个部分组成</strong>。</p>
</li>
<li><p>用例之间存在的关系包括：<strong>扩展、使用和组合三种关系</strong>。</p>
</li>
<li><p>UML2.0提供了13种不同的图，分为两类：</p>
<blockquote>
<p>结构图：类图、对象图、复合结构图、包图、组件图、部署图</p>
<p>行为图：用例图、交互图（顺序图、通信图、交互概述图、时间图）、状态图和活动图</p>
</blockquote>
</li>
<li><p>修改数据大小的语法是：<code>ALTER DATABASE 数据库名 MODIFY FILE(NAME=数据库文件名,SIZE=文件容量)</code><strong>其中文件容量必须大于原有容量</strong>。</p>
</li>
<li><p><strong>定义架构</strong>的语法格式：<code>create schema 架构名 authorization 用户名</code></p>
</li>
<li><p><strong>SQL Server实例的作业信息存储在<u>msdb</u>数据库中。</strong></p>
</li>
<li><p><strong>创建分区方案</strong>时指定的文件组数<strong>不得少于</strong>(不一定要相等)分区函数生成的分区数。</p>
</li>
<li><p><strong>如果未在声明游标时指定scroll</strong>，则<strong><u>NEXT</u></strong>是唯一支持的提取选项。</p>
</li>
<li><p>在<strong>视图</strong>上<strong>不能</strong>定义<strong>After型触发器</strong>。</p>
</li>
<li><p>创建登录账户：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> login username <span class="keyword">with</span> <span class="keyword">password</span>=passwordchar</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>数据库重组：</strong></p>
<blockquote>
<p>按照系统设计要求对数据库存储空间进行全面调整，如：</p>
<ol>
<li>调整磁盘分区方法和存储空间</li>
<li>重新安排数据的存储</li>
<li>整理回收碎块等</li>
</ol>
</blockquote>
</li>
<li><p>数据库应用系统投入运行<strong>标志着系统开发任务的基本完成</strong>和<strong>系统运行维护工作的开始</strong>。</p>
</li>
<li><p><strong>数据库运行维护</strong>工作包括：</p>
<blockquote>
<ol>
<li>数据库的转储和恢复；</li>
<li>数据库的安全性和完整性控制；</li>
<li>数据库性能的监控分析和改进；</li>
<li>数据库的重组和重构。</li>
</ol>
</blockquote>
</li>
<li><p>数据库差量备份：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">backup</span> <span class="keyword">database</span> students <span class="keyword">TO</span> MyBK_1 <span class="keyword">with</span> differential,noinit</span><br><span class="line"><span class="comment">--differential 表示差异备份  noinit表示 合并 不初始化</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>分布式数据库最基本的特征是：</p>
<blockquote>
<p>本地自治、非集中式管理、高可用性</p>
</blockquote>
</li>
<li><p>分布式数据库是物理上分散、逻辑上集中的数据库系统。</p>
</li>
<li><p>SaaS指 软件即服务（Software as a Service）</p>
</li>
<li><p>VB 6.0中的数据绑定控件必须具有<strong>DataSource属性</strong></p>
</li>
<li><p>VB 6.0中，ADO数据控件用于连接数据源的属性是<strong>ConnectionString</strong></p>
</li>
<li><p>一个<strong>完整的事务概要设计</strong>包括：</p>
<blockquote>
<ol>
<li><strong>事务用户</strong></li>
<li><strong>事务处理逻辑</strong></li>
<li><strong>事务名称</strong></li>
<li><strong>事务所访问的关系表及关系属性</strong></li>
</ol>
</blockquote>
</li>
<li><p>在数据库三级模式结构中，对数据库中全部的<strong>数据逻辑结构和特征</strong>进行描述的是 <strong><u>模式</u></strong>。</p>
</li>
<li><p>在分类预测任务重，需要用到的数据一般包括<strong>训练集、测试集和验证集。</strong></p>
</li>
<li><p>在数据库<u><strong>概要设计</strong></u>阶段，<strong>使用read和write原语来表达存取操作</strong>。</p>
</li>
<li><p>云计算通过集中所有的硬件计算资源，采用硬件<strong><u>虚拟技术</u></strong>，为使用者提供强大的计算能力、存储和带宽等资源。</p>
</li>
<li><p><strong>创建视图</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> 视图名 <span class="keyword">as</span></span><br><span class="line">	<span class="keyword">select</span> <span class="keyword">name</span>,age,sex <span class="keyword">from</span> student;</span><br><span class="line">go	</span><br><span class="line"><span class="comment">--调用视图</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> 视图名;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>创建索引</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span>  索引名 <span class="keyword">on</span> 表名(列);  <span class="comment">--普通索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> clustered <span class="keyword">index</span> 索引名 <span class="keyword">on</span> 表名(列);  <span class="comment">--唯一聚集索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> nonclustered <span class="keyword">index</span> 索引名 <span class="keyword">on</span> 表名(列);  <span class="comment">--唯一非聚集索引 </span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span>  索引名 <span class="keyword">on</span> 表名(列<span class="number">1</span>,列<span class="number">2</span>);  <span class="comment">--复合索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span>  索引名 <span class="keyword">on</span> 表名(列 <span class="keyword">desc</span>);  <span class="comment">--普通索引 按列 降序</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>存储过程</strong>：</p>
<p><strong>普通：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> 存储过程名 (@<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">10</span>),@age <span class="built_in">int</span>) <span class="keyword">As</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">name</span>=@<span class="keyword">name</span> <span class="keyword">and</span> age=@age</span><br><span class="line"><span class="keyword">go</span></span><br><span class="line"></span><br><span class="line">exec 存储过程名 <span class="string">'范XX'</span>,<span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<p><strong>带输入输出参数：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> 存储过程名 (</span><br><span class="line">    @<span class="keyword">id</span> <span class="built_in">int</span>,   <span class="comment">--默认输入</span></span><br><span class="line">	@<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">out</span>,   <span class="comment">--输出参数</span></span><br><span class="line">    @age <span class="built_in">int</span> <span class="keyword">output</span>    <span class="comment">--输入输出参数</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line">	<span class="keyword">select</span> @<span class="keyword">name</span>=<span class="keyword">name</span>,@age=age <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">id</span>=@<span class="keyword">id</span> <span class="keyword">and</span> age=@age;  <span class="comment">--根据id和年龄查询 并 返回 姓名和年龄	</span></span><br><span class="line">go</span><br><span class="line"></span><br><span class="line"><span class="comment">--调用存储过程</span></span><br><span class="line"><span class="keyword">declare</span> @<span class="keyword">id</span> <span class="built_in">int</span>,@<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">10</span>),@age <span class="built_in">int</span>;   <span class="comment">--定义变量</span></span><br><span class="line"><span class="comment">--给输入参数赋值</span></span><br><span class="line"><span class="keyword">set</span> @<span class="keyword">id</span>=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">set</span> @age=<span class="number">20</span>;</span><br><span class="line"><span class="comment">--调用存储</span></span><br><span class="line">exec 存储过程名 @id,@name out,@age output;</span><br><span class="line"><span class="comment">--查看返回的值</span></span><br><span class="line"><span class="keyword">select</span> @<span class="keyword">name</span>,@age;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>标量函数</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> 函数名 (@<span class="keyword">id</span> <span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">returns</span> <span class="built_in">varchar</span>(<span class="number">10</span>)  <span class="comment">--定义返回值类型</span></span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">declare</span> @<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">select</span> @<span class="keyword">name</span>=<span class="keyword">name</span> <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">id</span>=@<span class="keyword">id</span>;   <span class="comment">--给@name 变量赋值</span></span><br><span class="line">	return @name <span class="comment">--返回@name变量</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--调用</span></span><br><span class="line"><span class="keyword">select</span> dbo.函数名(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>(*)多语句表值函数</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> 函数名(@<span class="keyword">id</span> <span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">returns</span> @表变量名 <span class="keyword">table</span> (</span><br><span class="line">	<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">10</span>),</span><br><span class="line">    age <span class="built_in">int</span>,</span><br><span class="line">    sex <span class="built_in">varchar</span>(<span class="number">4</span>)</span><br><span class="line">)   <span class="comment">--定义返回值表结构</span></span><br><span class="line"><span class="keyword">as</span></span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">insert</span> <span class="keyword">into</span> @表变量名(<span class="keyword">name</span>,age,sex) <span class="keyword">select</span> <span class="keyword">name</span>,age,sex <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">id</span>=@<span class="keyword">id</span>  <span class="comment">--给返回表赋值</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--分割线--</span></span><br><span class="line"><span class="comment">--调用</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,age,sex <span class="keyword">from</span> dbo.函数名(<span class="number">22</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>内嵌表值函数</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> 函数名(@<span class="keyword">id</span> <span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">returns</span> <span class="keyword">table</span>  <span class="comment">--返回值是一个表</span></span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">select</span> <span class="keyword">name</span>,age,sex <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">id</span>=@<span class="keyword">id</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--分割线--</span></span><br><span class="line"><span class="keyword">go</span></span><br><span class="line"><span class="comment">--调用</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> 函数名(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>分区函数、分区方案和分区表</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--分区函数</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">partition</span> <span class="keyword">function</span> RangePF(<span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">as</span> <span class="keyword">Range</span> <span class="keyword">Left</span> <span class="keyword">For</span> <span class="keyword">Values</span>(<span class="number">100</span>,<span class="number">200</span>,<span class="number">300</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">--根据上面的分区函数创建分区方案</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">partition</span> scheme RangePS</span><br><span class="line"><span class="keyword">as</span> <span class="keyword">partition</span> RangePF <span class="keyword">to</span>(fg1,fg2,fg3,fg4)  <span class="comment">--四个文件组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--根据上面的分区方案创建分区表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> myTable(</span><br><span class="line">	Gid <span class="built_in">int</span> <span class="keyword">identity</span>(<span class="number">1</span>,<span class="number">1</span>) primary <span class="keyword">key</span>,</span><br><span class="line">    GoodName <span class="built_in">varchar</span>(<span class="number">40</span>),</span><br><span class="line">    Price <span class="built_in">float</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">on</span> RangePS(Gid)</span><br><span class="line"><span class="comment">--结束</span></span><br></pre></td></tr></table></figure>



</li>
</ol>

      
      <!-- reward 打赏按钮-->
      
      <div id="reward-btn">
        打赏
      </div>
      
    </div>
    
    
      <!-- copyright 版权声明-->
      
        <div class="declare">
          <ul class="post-copyright">
            <li>
              <i class="ri-copyright-line"></i>
              <strong>Copyrights： </strong>
              版权归作者所有。如需商业转载，请与作者联系以获得授权。非商业性转载请注明出处。
            </li>
          </ul>
        </div>
        
    <footer class="article-footer">
      
          
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://itaylorfan.github.io/2021/03/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%85%B6%E4%BB%96/" rel="tag">其他</a></li></ul>


    </footer>

  </div>

  
  
  <nav class="article-nav">
    
      <a href="/2021/10/21/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            正则表达式
          
        </div>
      </a>
    
    
      <a href="/2021/02/23/node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">node学习笔记</div>
      </a>
    
  </nav>


  

  
  
<!-- valine评论 -->
<div id="vcomments-box">
    <div id="vcomments">
    </div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>
<script>
    new Valine({
        el: '#vcomments',
        app_id: 'IUPFYr9b7ardBDF78isygkav-gzGzoHsz',
        app_key: 'SX7yhiWLzh7seYDtIzHyJOfH',
        path: window.location.pathname,
        notify: 'false',
        verify: 'false',
        avatar: 'monsterid',
        placeholder: '给我的文章加点评论吧~',
        recordIP: true
    });
    const infoEle = document.querySelector('#vcomments .info');
    if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
        infoEle.childNodes.forEach(function (item) {
            item.parentNode.removeChild(item);
        });
    }
</script>
<style>
    #vcomments-box {
        padding: 5px 30px;
    }

    @media screen and (max-width: 800px) {
        #vcomments-box {
            padding: 5px 0px;
        }
    }

    #vcomments-box #vcomments {
        background-color: #fff;
    }

    .v .vlist .vcard .vh {
        padding-right: 20px;
    }

    .v .vlist .vcard {
        padding-left: 10px;
    }
</style>

  

  
  
  
  
  

</article>
</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2020-2022
        <i class="ri-heart-fill heart_icon"></i> ITaylorfan
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Theme - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
        <li>
          <a href="https://beian.miit.gov.cn/#/Integrated/index" target="_black">鄂ICP备2020023396号</a>
        </li>
        
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>

      <li>
       <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
      </li>
    </ul>

   
   <!-- 统计网站运行时间 -->
<script>
    var now = new Date(); 
    function createtime() { 
        var grt= new Date("04/23/2020 12:00:00");//此处修改你的建站时间或者网站上线时间 
        now.setTime(now.getTime()+250); 
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
        snum = Math.round(seconds); 
        <!-- 加判断条件避免出现60秒的情况 -->
	if(snum==60){
	    snum=0;
	  }

	if(String(snum).length ==1 ){snum = "0" + snum;} 
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "; 
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
    } 
setInterval("createtime()",250);
</script>

  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/TS-10-21-2.jpg" alt="ITaylorfan的博客"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/hexo/">hexo</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E5%89%8D%E7%AB%AF">前端</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E5%85%B6%E4%BB%96">其他</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/me">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/WeChat.png">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script>
  try {
    var typed = new Typed("#subtitle", {
      strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
      startDelay: 0,
      typeSpeed: 200,
      loop: true,
      backSpeed: 100,
      showCursor: true
    });
  } catch (err) {
  }

</script>




<script src="/js/tocbot.min.js"></script>

<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>



<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>



<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>





<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>

  
<script src="/js/clickLove.js"></script>



<!-- 复制 -->

  
<link rel="stylesheet" href="/css/clipboard.css">

  <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>




    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=1835283134&auto=0&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
  </div>
  <script src="/live2d-widget/autoload.js"></script>
</body>

</html>